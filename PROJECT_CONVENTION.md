# Project Coding Context & Conventions

프로젝트의 폴더 구조와 책임 경계를 명확히 하여, 어디에 무엇을 작성해야 하는지 일관된 기준을 제공합니다. 아래 원칙을 따르지 않으면 변경 비용이 기하급수적으로 증가하므로, 새 기능/수정 전 반드시 이 문서를 확인하세요.

## 최상위 폴더 책임

- `src/`: 애플리케이션의 모든 프로덕션 소스 코드. 도메인 규칙, 유즈케이스, 외부 어댑터 구현 포함
- `scripts/`: 개발자가 수동 실행하는 CLI/유틸 스크립트. 모듈을 호출하는 thin wrapper여야 함
- `tests/`: 테스트 코드. 단위/통합/외부 API/느린 테스트/Mocking 없는 실제 통합 테스트 등을 `pytest.ini` 마커에 맞춰 분리

## Architecture와 의존성 규칙

의존성 방향은 아래와 같습니다. 역참조는 금지됩니다.

```
domain  ←  application  ←  interface/dags/scripts
   ↑           ↑
   └────────── infrastructure
```

- 상위 레이어는 하위 레이어를 import할 수 있지만, 반대는 금지
- `domain`은 어떤 레이어도 import하지 않음(순수성 보장)
- `infrastructure`는 `domain`을 의존해 구현체를 제공할 수 있음
- `application`은 `domain`과 `infrastructure`를 조합해 유즈케이스를 구현
- `dags`/`scripts`는 오케스트레이션/엔트리로서 `application`을 호출만 함

## src/ 하위 폴더별 책임과 작업 기준

### 1) `src/domain/` — 순수 도메인 계층 (비즈니스 규칙의 심장)

- 포함: `base/`(추상 인터페이스), `models/`(도메인 서비스/엔티티), `prompts/`, `responses/`, `schemas/`(Pydantic), `types.py`, `exceptions.py`, `prompts`(프롬프트 보관)
- 금지: 네트워크/파일 IO, DB 접속, 환경변수 접근, 로깅 종속, 프레임워크 의존
- 허용: 순수 함수/메서드, 데이터 모델 검증, 예외 정의, Provider 인터페이스 정의
- 언제 수정/추가하나?
  - 새 비즈니스 개념/데이터 구조가 필요할 때 (`schemas`, `models`)
  - 프롬프트/출력 스키마 등 모델 불가지론적 규칙을 바꿀 때 (`prompts`, `responses`)
  - 외부 의존이 없는 로직을 리팩터링할 때

### 2) `src/infrastructure/` — 외부 세계 어댑터/클라이언트 구현

- 포함: `llm/`(예: `openai_client.py`, `gemini_client.py`, `factory.py`, `structured_output_manager.py`), `db/`(예: `mongo.py`)
- 허용: 외부 API/DB/파일 IO, 환경설정(`src/settings.py`) 접근, 로깅
- 규칙: `domain.base`에 정의된 인터페이스를 구현하고, 입력/출력은 가능한 `domain` 모델 사용
- 언제 수정/추가하나?
  - 새로운 외부 서비스/프로바이더/DB 드라이버를 붙일 때
  - Structured Output/파싱/리트라이/레이트리밋 등 기술적 concern을 개선할 때

### 3) `src/application/` — 유즈케이스/파이프라인 오케스트레이션

- 역할: 도메인 로직과 인프라 구현을 조합해 배치/파이프라인/서비스 유즈케이스를 완성
- 규칙: 
  - 비즈니스 규칙은 가능하면 `domain`에 위치시키고, 여기서는 조립/흐름 제어/멱등성/분기만 수행
  - 외부 호출은 반드시 `infrastructure` 구현을 통해 간접적으로 수행
  - 재시도/모니터링/에러격리/멱등성(Idempotency) 고려
- 언제 수정/추가하나?
  - 파이프라인 단계/유즈케이스를 신설/변경할 때 (예: 전처리→식별→평가→저장 흐름)
  - 애플리케이션 수준 파라미터/전략을 바꿀 때

### 4) `src/interface/` — 인바운드 어댑터/프리젠테이션 레이어

- 포함(예시 디렉토리): `api/`(REST/gRPC/Web), `cli/`(Typer/Click), `webhook/`, `consumers/`(이벤트/큐 소비자), `dto/`(요청/응답 모델)
- 역할: 외부에서 들어온 입력을 검증/권한 확인/역직렬화하고 `application`의 유즈케이스를 호출하여 결과를 직렬화해 반환
- 금지: 비즈니스 규칙 구현, DB/외부 API 직접 접근, LLM 직접 호출, 환경설정 로직 보관
- 규칙:
  - 입력/출력 DTO는 인터페이스 전용 모델을 사용하고, `application` 경계에서 도메인 모델로 변환
  - 인증/인가, 레이트리밋, 요청 중복 방지 키(Idempotency-Key) 등 엣지 책임 처리
  - 예외 매핑: `domain.exceptions` → HTTP 상태코드/CLI 종료코드로 일관 매핑
  - 로깅은 최소한으로(PII 마스킹), 트레이싱 컨텍스트 전달
- 언제 수정/추가하나?
  - 새로운 엔드포인트/웹훅/CLI 명령 등 외부 진입점이 필요할 때
  - 요청/응답 포맷 버저닝 또는 인증정책이 변경될 때

## 테스트 전략 (`tests/`) 폴더 

- 마커: `unit`, `integration`, `api`, `slow`를 `pytest.ini` 기준으로 사용
- 구조: `tests/application/...`, `tests/unit/...` 등 프로덕션 경로 미러링
- 원칙:
  - 행동 기반(외부 행위/계약) 검증, 내부 구현 세부사항 의존 금지
  - 외부 API/DB는 목/페이크로 격리. 통합 테스트는 최소 happy-path만
  - 실패 케이스/에러 경계(예외, 타임아웃, 재시도, 멱등성) 포함
  - 픽스처/파라미터화로 가독성과 재사용성 확보

## 좋은 테스트의 4가지 기둥:
- 회귀 방지 (Protection against Regressions): 소프트웨어의 안정성을 지키는 가장 중요한 요소로, 버그 발생을 막는 능력을 의미합니다. 코드의 복잡도가 높고, 실행되는 양이 많으며, 비즈니스 로직의 핵심(도메인 영역)일수록 회귀 방지의 가치는 극대화됩니다. 우리가 작성한 코드뿐만 아니라, 사용하는 라이브러리와 프레임워크가 예상대로 동작하는지 검증하는 것 또한 중요합니다.

- 리팩터링 내성 (Resistance to Refactoring): 내부 구조를 개선하는 리팩터링 과정에서 테스트가 실패해서는 안 됩니다. 기능적으로는 완벽하게 동일한데도 테스트가 실패하는 '거짓 양성(false positive)'이 반복되면, 개발자는 테스트 결과를 불신하게 됩니다. 이러한 불신은 실제 버그가 발생했을 때 이를 간과하게 만드는 원인이 됩니다. 리팩터링 내성을 확보하려면, 테스트가 구현의 세부 사항이 아닌, 변경되지 않는 추상화된 동작(인터페이스)을 기반으로 결과를 검증해야 합니다.

- 빠른 피드백 (Fast Feedback): 테스트 실행 속도가 빠를수록 개발자는 더 신속하게 문제점을 인지하고 수정할 수 있습니다. 버그 발견과 수정 사이의 시간이 짧아질수록 비용은 기하급수적으로 줄어듭니다.

- 유지보수 용이성 (Maintainability): 테스트 코드도 유지보수해야 할 비용입니다. 테스트 코드가 읽기 쉽고, 이해하기 쉬우며, 실행하기 간편해야 합니다. 유지보수 비용이 높은 테스트는 결국 방치되고 가치를 잃게 됩니다. 


## TDD 구현 원칙과 테스트 작성 스타일

### 구현 원칙
모든 기능 구현/리팩터링/버그 수정은 필요한 테스트 케이스를 먼저 작성한 뒤 구현한다(TDD).

테스트는 내부 구현이 아닌 관찰 가능한 행동(계약)을 검증한다: 가장 흔한 실수 중 하나는 클래스나 메서드 같은 '코드' 단위로 테스트를 작성하는 것입니다. 이러한 테스트는 구현에 강하게 결합되어 리팩터링 내성을 심각하게 저해합니다. 가치 있는 단위 테스트는 시스템 외부의 클라이언트 관점에서 의미 있는 결과, 즉 **'식별할 수 있는 동작(Observable Behavior)'**을 단위로 검증해야 합니다. 이는 클라이언트의 목표를 달성시켜주는 공개된(public) 연산을 의미하며, 주로 변경될 여지가 적은 비즈니스 요구사항과 직결됩니다. 이를 위해서는 세부 구현은 private으로 숨기고, 의미 있는 동작만을 public으로 노출하는 캡슐화가 선행되어야 합니다. 이는 외부에서 객체의 상태를 묻지 않고, 원하는 바를 시키도록 하는 'Tell, Don't Ask' 원칙과도 일맥상통합니다.

추가 규칙 
- 단위 테스트는 빠르게, 외부 의존은 목/페이크로 격리. 통합 테스트는 핵심 경로만 최소화.
- 유사 케이스는 `pytest.mark.parametrize`로 가독성 있게 묶는다.
 내부 구현 세부와 결합된 취약한 assert(사소한 로깅/비공개 속성 등)는 지양한다.

### 작성 스타일(GIVEN / WHEN / THEN)

준비 (Arrange/Given): 테스트에 필요한 객체와 상태를 설정합니다. 준비 구문이 너무 복잡하다면 별도의 팩토리 메서드나 클래스로 분리하여 가독성을 높이는 것이 좋습니다.

실행 (Act/When): 테스트 대상이 되는 핵심 동작(메서드)을 실행합니다. 이 부분은 한 줄로 명확하게 표현되는 것이 이상적이며, 여러 줄이라면 API 설계의 캡슐화 문제를 의심해볼 수 있습니다.

검증 (Assert/Then): 실행의 결과가 예상과 일치하는지 확인합니다. 하나의 동작으로 인해 여러 상태가 변경될 수 있으므로, 검증문이 반드시 하나일 필요는 없습니다. 관련된 검증은 클래스로 묶어 재사용할 수 있습니다.

### 문서화(주석/설명)

이 프로젝트를 처음 접하는 개발자도 이해할 수 있도록 테스트 함수 상단에 한글 docstring으로 시나리오 요약과 비즈니스 맥락을 상세히 적는다.

테스트 본문에는 단계별로 주석에 GIVEN / WHEN / THEN 라벨을 달아 구분한다.

"왜"(의도/도메인 규칙)를 설명하고, 구현 세부(어떻게)는 과도하게 서술하지 않는다.

네이밍 권장: `test_<단위/기능>__given_<상태>__when_<행위>__then_<결과>`

### 테스트할 코드 식별하기

모든 코드가 테스트할 가치가 있는 것은 아닙니다. 코드의 가치는 **(복잡도 및 도메인 중요도) x (협력자 수)**로 판단할 수 있습니다.

도메인 모델과 알고리즘: 복잡하고 중요하므로 반드시 단위 테스트가 필요합니다.

간단한 코드: 테스트 가치가 거의 없습니다.

컨트롤러/서비스: 여러 협력자와 함께 동작하므로 통합 테스트에 적합합니다.

지나치게 복잡한 코드: 비즈니스 로직과 외부 의존성(DB, API 호출 등)이 한데 얽혀 테스트하기 매우 어려운 코드입니다. 이 코드는 반드시 분리해야 합니다.

험블 객체 패턴(Humble Object Pattern): '지나치게 복잡한 코드'를 테스트 가능한 구조로 바꾸는 강력한 리팩터링 패턴입니다. 핵심은 비즈니스 로직과 외부 의존성을 다루는 로직(오케스트레이션)을 분리하는 것입니다. 기존의 복잡한 클래스에서 순수한 비즈니스 로직만을 새로운 클래스(도메인 모델)로 추출합니다. 기존 클래스는 '험블(Humble)' 객체, 즉 오케스트레이션 역할만 하는 껍데기로 남습니다. 이 객체는 외부 의존성을 주입받아 비즈니스 로직 클래스에 전달하는 역할만 수행합니다. 이렇게 분리하면, 복잡했던 비즈니스 로직은 외부 의존성 없이 순수하게 단위 테스트할 수 있게 되고, 험블 객체는 통합 테스트를 통해 검증할 수 있습니다.


## Unit Testing 작성 원칙: 

유닛 테스트의 가장 중요한 목적은 단순히 버그를 예방하는 것을 넘어, 엔지니어의 생산성을 향상시키는 데 있습니다. 훌륭한 유닛 테스트는 빠르고, 작성하기 쉬우며, 높은 코드 커버리지를 촉진하고, 실패 시 원인을 명확히 알려주며, 그 자체로 훌륭한 문서가 됩니다.

유지보수 불가능한 테스트는 주로 두 가지 문제점을 가집니다.
1. **취약함 (Brittle)**: 실제 버그를 유발하지 않는 무해한 코드 변경에도 불구하고 테스트가 실패합니다.
2. **불분명함 (Unclear)**: 테스트가 실패했을 때, 무엇이 잘못되었는지, 어떻게 수정해야 하는지, 그리고 원래 테스트가 무엇을 검증하려 했는지 파악하기 어렵습니다.

### **불변의 테스트를 지향하라 (Strive for Unchanging Tests):**

이상적인 테스트는 한번 작성된 후, **테스트 대상 시스템의 요구사항이 변경되지 않는 한 절대 수정될 필요가 없는 테스트**입니다.

- **리팩토링**: 시스템 내부 구현을 개선하는 순수한 리팩토링 시에는 기존 테스트가 변경되어서는 안 됩니다. 테스트는 이 과정에서 시스템의 동작이 변하지 않았음을 보장하는 안전망 역할을 해야 합니다.
- **새 기능 추가**: 새로운 기능을 추가할 때도 기존 테스트는 그대로 유지되어야 합니다. 새로운 동작을 검증하기 위한 새로운 테스트만 추가되어야 합니다.
- **버그 수정**: 버그 수정은 누락된 테스트 케이스를 추가하는 과정이며, 기존 테스트를 수정할 필요가 없습니다.

오직 시스템의 **공개적인 동작 자체가 변경**될 때만 기존 테스트를 수정해야 합니다.

### 공개 API를 통해 테스트하라 (Test via Public APIs)

테스트가 취약해지는 가장 큰 이유는 테스트가 시스템의 **구현 세부사항에 의존**하기 때문입니다. 이를 방지하는 가장 중요한 방법은 **시스템의 사용자와 동일한 방식으로, 즉 공개 API를 통해서만 테스트하는 것**입니다.

테스트가 비공개 메서드를 호출하거나 내부 상태를 직접 확인하면, 시스템 내부 구조가 조금만 바뀌어도 테스트는 쉽게 깨집니다. 하지만 공개 API를 통해 테스트하면, 테스트가 실패하는 것은 실제 사용자에게도 영향을 미치는 '계약 위반'을 의미하게 됩니다. 이는 테스트를 훨씬 더 의미 있고 견고하게 만듭니다.

### 상호작용이 아닌 상태를 테스트하라 (Test State, Not Interactions)

테스트가 시스템의 동작을 검증하는 방식은 두 가지입니다.

1. **상태 테스트 (State Testing)**: 시스템과 상호작용한 후, 시스템의 최종 **상태**가 예상과 같은지 확인합니다. (예: `createUser()` 호출 후 `getUser()`를 통해 사용자가 존재하는지 확인)
2. **상호작용 테스트 (Interaction Testing)**: 시스템이 특정 동작을 수행하기 위해 협력 객체(collaborator)와 **어떻게 상호작용**했는지를 확인합니다. (예: `createUser()` 호출 시 `database.put()`이 정확히 호출되었는지 확인)

**상호작용 테스트는 상태 테스트보다 훨씬 더 취약합니다.** 이는 시스템이 '어떻게' 결과를 만들어냈는지를 검증하기 때문입니다. 우리는 대부분 '어떤' 결과가 나왔는지에만 관심을 가져야 합니다. 상호작용 테스트, 특히 모킹 프레임워크(mocking framework)를 과도하게 사용하면 테스트가 구현 세부사항에 강하게 결합되어 사소한 리팩토링에도 쉽게 깨지게 됩니다. 따라서 구글에서는 **상태 테스트를 압도적으로 선호**합니다.

---

### 명확한 테스트 작성하기 (Writing Clear Tests)

테스트가 아무리 견고해도 언젠가는 실패하기 마련입니다. 테스트 실패는 시스템의 문제를 알려주는 유용한 신호이므로 좋은 일입니다. 이때 엔지니어의 첫 번째 임무는 실패의 원인을 신속하게 진단하는 것이며, 이는 **테스트의 명확성(clarity)**에 달려 있습니다.

명확한 테스트란 실패했을 때 그 존재 이유와 실패 원인이 즉시 명확하게 드러나는 테스트입니다. 불분명한 테스트는 결국 아무도 수정 방법을 알지 못해 삭제되거나, 수년간 아무런 가치도 제공하지 못하는 기술 부채로 남게 됩니다.

### 테스트를 완전하고 간결하게 만들어라 (Make Your Tests Complete and Concise)

명확한 테스트는 두 가지 속성을 가집니다.

- **완전성 (Completeness)**: 테스트 본문이 결과를 이해하는 데 필요한 **모든 정보**를 담고 있어야 합니다. 중요한 값이 헬퍼 메서드 안에 숨겨져 있어서는 안 됩니다.
- **간결성 (Conciseness)**: 테스트의 핵심 동작과 관련 없는 **불필요하거나 주의를 분산시키는 정보**가 없어야 합니다.

예를 들어, 테스트 대상 객체를 생성할 때 테스트와 무관한 수많은 인자를 전달하는 것은 간결성을 해치며, `2 + 3`을 테스트하면서 그 숫자들을 다른 헬퍼 함수 안에 숨기는 것은 완전성을 해칩니다.

---

### 메서드가 아닌 동작을 테스트하라 (Test Behaviors, Not Methods)

많은 엔지니어들이 운영 코드의 메서드 하나당 테스트 메서드 하나를 작성하는 경향이 있습니다. 하지만 이 방식은 운영 메서드가 복잡해질수록 테스트도 함께 복잡하고 불분명해지는 문제를 낳습니다.

더 나은 방법은 **메서드가 아닌 동작(behavior) 단위로 테스트를 작성**하는 것입니다. 동작이란 "특정 상태(Given)에서, 특정 작업을 수행했을 때(When), 특정 결과가 나타난다(Then)"로 표현할 수 있는 시스템의 보증입니다. 하나의 메서드는 여러 동작을 포함할 수 있고, 하나의 동작이 여러 메서드에 걸쳐 있을 수도 있습니다.

각 테스트가 단 하나의 동작에만 집중하면, 테스트는 더 짧고, 이름은 더 서술적이 되며, 실패 시 원인을 파악하기 훨씬 쉬워집니다.

---

### 동작을 강조하도록 테스트를 구조화하고 이름을 지어라

- **테스트 구조화 (Structure Tests)**: 좋은 테스트는 **Given / When / Then** 구조를 명확히 따릅니다. 주석이나 공백을 사용해 이 세 부분을 시각적으로 분리하면, 독자는 테스트 이름만 보고 개요를 파악하고, 주석을 통해 동작을 이해한 뒤, 코드를 통해 구체적인 내용을 확인할 수 있습니다.
- **테스트 이름 짓기 (Name Tests)**: 테스트 이름은 실패 보고서에서 가장 먼저 보게 되는 정보이므로 매우 중요합니다. 테스트 이름은 검증하려는 **동작을 요약**해야 합니다. 즉, 어떤 조건에서 어떤 작업을 수행하면 어떤 결과가 나오는지를 설명해야 합니다. 예를 들어, `updateBalance` 메서드를 테스트하는 경우 `testUpdateBalance` 대신 `shouldNotAllowWithdrawalsWhenBalanceIsEmpty` (잔액이 없을 때 출금을 허용해서는 안 된다)와 같이 서술적으로 작성하는 것이 좋습니다.

### 테스트에 로직을 넣지 마라 (Don’t Put Logic in Tests) 🧠

명확한 테스트는 **한눈에 봐도 사소할 정도로 정확해야 합니다.** 즉, 코드를 읽는 것만으로도 테스트가 올바른 작업을 수행하고 있다는 것이 명백해야 합니다.

테스트 코드에 조건문, 반복문, 복잡한 문자열 연산과 같은 **로직**이 포함되면, 독자는 결과를 단순히 읽는 것이 아니라 머릿속으로 계산해야 합니다. 이는 테스트의 의도를 파악하기 어렵게 만들고, 심지어 테스트 자체에 버그가 숨어있을 가능성을 높입니다.

예를 들어, 예상 URL을 만들기 위해 테스트 코드 내에서 문자열을 조합하는 것(`baseUrl + "/albums"`)보다, 완전한 URL 문자열을 직접 작성하는 것이 좋습니다. 후자의 경우, `"http://.../photos//albums"`와 같이 잘못된 부분이 즉시 눈에 띄기 때문입니다. 테스트 코드에서는 약간의 중복을 감수하더라도 명시성을 높이는 것이 훨씬 더 가치 있습니다.

---

### 명확한 실패 메시지를 작성하라 (Write Clear Failure Messages) 📢

테스트의 명확성은 테스트가 실패했을 때 엔지니어가 보게 될 **실패 메시지**에서도 드러납니다. 이상적인 실패 메시지는 엔지니어가 테스트 코드를 직접 보지 않고도 문제의 원인을 진단할 수 있게 해줍니다.

좋은 실패 메시지는 다음 정보를 포함해야 합니다.

- **기대했던 결과**
- **실제 결과**
- **관련된 매개변수**

나쁜 메시지: `Test failed: account is closed`
좋은 메시지: `Expected an account in state CLOSED, but got account <{name: "my-account", state: "OPEN"}>`

좋은 단언(assertion) 라이브러리를 사용하면 이러한 유용한 실패 메시지를 더 쉽게 작성할 수 있습니다.

---

### 테스트와 코드 공유: DAMP, Not DRY

소프트웨어 개발의 유명한 원칙 중 하나는 **DRY(Don't Repeat Yourself, 반복하지 말라)**입니다. 하지만 테스트 코드에서는 이 원칙이 항상 최선은 아닙니다.

- **DRY의 문제점**: 테스트 코드에서 과도하게 중복을 제거하면 중요한 정보가 헬퍼 메서드 안으로 숨겨져 테스트의 **완전성**과 **명확성**이 저해될 수 있습니다.
- **DAMP를 지향하라**: 테스트 코드는 DRY 대신 **DAMP(Descriptive And Meaningful Phrases, 서술적이고 의미 있는 구문)**를 지향해야 합니다. 이는 테스트를 더 단순하고 명확하게 만들 수 있다면, 약간의 코드 중복은 괜찮다는 의미입니다.

각 테스트는 그 자체로 완전하고 이해하기 쉬워야 합니다. 중복을 줄이기 위해 모든 로직을 복잡한 헬퍼 메서드로 추출하는 것보다, 각 테스트 본문에 필요한 값을 명시적으로 선언하는 것이 훨씬 더 낫습니다.

---

### 효과적인 코드 공유 패턴

그렇다고 해서 테스트에서 모든 코드 공유를 피해야 하는 것은 아닙니다. 다음은 명확성을 해치지 않으면서 코드를 효과적으로 공유하는 패턴입니다.

- **공유 값 (Shared Values)**: `ACCOUNT_1`과 같이 모호한 이름의 상수를 공유하는 대신, 테스트 데이터 생성을 위한 **헬퍼 메서드**나 **빌더(Builder) 패턴**을 사용하는 것이 좋습니다. 이를 통해 각 테스트는 자신이 관심 있는 값만 명시적으로 설정하고, 나머지는 합리적인 기본값으로 둘 수 있어 테스트의 의도가 명확해집니다.
- **공유 설정 (Shared Setup)**: 많은 테스트 프레임워크는 각 테스트 실행 전에 실행되는 `setUp` 메서드를 지원합니다. 이는 테스트 대상 객체와 그 협력 객체를 기본 상태로 생성하는 데 유용합니다. 단, 테스트가 `setUp`에서 설정된 특정 값에 암묵적으로 의존해서는 안 됩니다. 만약 특정 값이 중요하다면, 테스트 본문 내에서 명시적으로 그 값을 설정해야 합니다.
- **공유 헬퍼 및 검증 (Shared Helpers and Validation)**: 모든 테스트 끝에 일반적인 `validate()` 헬퍼를 호출하는 것은 좋지 않습니다. 이는 테스트를 덜 행동 중심으로 만들고, 실패 시 원인 파악을 어렵게 합니다. 대신, 단일 개념의 사실을 검증하는 매우 집중된 헬퍼 메서드를 사용하는 것이 좋습니다.

결론적으로, 유닛 테스트는 시스템이 예상대로 계속 작동하도록 보장하는 강력한 도구입니다. 하지만 부주의하게 작성된 테스트는 오히려 유지보수를 어렵게 만드는 짐이 될 수 있습니다. 이 장에서 설명한 원칙들(견고함, 명확함, DAMP)을 따르면, 시간이 지나도 그 가치를 잃지 않는 고품질의 유닛 테스트를 작성할 수 있을 것입니다.


## 통합 테스트 작성 원칙: 

통합 테스트는 주로 시스템의 핵심 유스케이스나 단위 테스트로 다루기 어려운 예외 상황(Edge Case)을 검증하는 데 사용됩니다.

외부 의존성 처리 원칙: 통합 테스트의 핵심은 외부 의존성을 어떻게 다룰 것인가에 있습니다. 관리 의존성 (Managed Dependency): 데이터베이스처럼 우리가 직접 제어할 수 있는 의존성입니다. 이는 실제 객체를 사용하는 것을 원칙으로 합니다. 목(Mock)으로 대체하면 데이터베이스 스키마 변경이나 ORM 동작 방식의 변화를 감지하지 못해 리팩터링 내성이 깨지기 쉽습니다. 비관리 의존성 (Unmanaged Dependency): 이메일 발송 서비스나 메시지 큐처럼 우리가 직접 제어할 수 없는 외부 서비스입니다. 이는 부작용(실제 메일 발송 등)을 방지하기 위해 목(Mock)으로 대체하는 것이 좋습니다. 이러한 서비스는 하위 호환성을 보장하는 경우가 많아 목으로 처리해도 리팩터링 내성을 해칠 확률이 낮습니다.

통합 테스트는 준비 과정이 복잡한 경우가 많습니다. 중복되는 코드는 적극적으로 재사용하여 유지보수 비용을 줄여야 합니다. 
- 준비 구절: 테스트 데이터 생성 로직은 private 팩토리 메서드나 별도의 헬퍼 클래스(Object Mother 패턴)로 분리합니다. 
- 실행 구절: 트랜잭션 처리 등 공통적인 실행 로직은 데코레이터 패턴 등을 활용해 재사용할 수 있습니다.
- 검증 구절: 반복되는 검증 로직은 플루언트 인터페이스(Fluent Interface) 기반의 확장 메서드로 만들어 가독성과 재사용성을 높일 수 있습니다.

## 테스트 더블 원칙 

테스트 더블을 도입하면 소프트웨어 개발에 몇 가지 중요한 고려사항이 생깁니다.
- 테스트 용이성 (Testability): 코드는 테스트 더블을 사용할 수 있도록 설계되어야 합니다. **의존성 주입(Dependency Injection)**과 같은 기법을 통해, 운영 환경의 실제 구현을 테스트 환경의 더블로 쉽게 교체할 수 있는 **'심(seam)'**을 만들어야 합니다.
- 적용 가능성 (Applicability): 테스트 더블은 만병통치약이 아닙니다. 잘못 사용하면 유지보수하기 어려운 테스트를 낳게 되므로, 많은 경우 실제 구현을 사용하는 것이 더 낫습니다.
- 충실도 (Fidelity): 테스트 더블이 실제 구현의 동작을 얼마나 유사하게 모방하는지를 의미합니다. 충실도가 낮은 테스트 더블은 거의 가치가 없습니다.

## 실제 구현을 우선하라 (Real Implementations First)
테스트 더블은 유용한 도구이지만, 구글의 테스트 철학에서 첫 번째 선택은 항상 **실제 구현(real implementation)**을 사용하는 것입니다.

현실성 대 고립성 (Realism Over Isolation): 실제 구현을 사용하면 테스트가 운영 환경의 동작을 더 현실적으로 반영하여, 시스템이 올바르게 작동한다는 더 강한 확신을 줍니다. 반면, 모든 의존성을 테스트 더블로 교체하는 것은 테스트 대상을 인위적으로 고립시켜, 실제로는 발생할 수 있는 의존성과의 상호작용 문제를 놓치게 할 수 있습니다.

언제 실제 구현을 사용해야 하는가?: 실제 구현이 빠르고(fast), 결정적이며(deterministic), 의존성 구조가 단순할 때 우선적으로 사용해야 합니다. 금액이나 날짜 같은 값 객체(value object)나 간단한 유틸리티 클래스가 좋은 예입니다.

언제 테스트 더블을 고려해야 하는가?: 실제 구현이 다음 중 하나에 해당할 때 테스트 더블을 고려합니다.
- 실행 시간 (Execution Time): 너무 느려서 개발자의 피드백 루프를 방해할 때.
- 비결정성 (Nondeterminism): 외부 서비스, 시스템 시간, 스레드 스케줄링 등에 의존하여 테스트가 불안정(flaky)해질 때.
- 의존성 구성의 복잡성 (Dependency Construction): 실제 객체를 생성하는 데 너무 많은 의존성을 설정해야 할 때.

### 페이킹 (Faking) 활용 
실제 구현(Real Implementation)을 테스트에 사용하기 어려울 때, 구글이 가장 선호하는 대안은 **페이크(Fake)**를 사용하는 것입니다. 페이크는 다른 테스트 더블 기법보다 월등히 나은 선택지로 여겨집니다.

## 페이킹이란 무엇인가? (What is Faking?)

페이크는 실제 구현의 API를 경량으로 재구현한 것으로, 실제와 유사하게 동작하지만 운영 환경에는 적합하지 않은 버전을 의미합니다. 대표적인 예로 실제 디스크에 데이터를 쓰는 대신 **인메모리 데이터베이스(in-memory database)**를 사용하는 것을 들 수 있습니다.

페이크는 시스템이 실제 구현과 상호작용하는지, 페이크와 상호작용하는지조차 구분할 수 없어야 합니다. 이처럼 높은 수준의 동작 유사성 때문에 페이크는 매우 강력한 테스트 도구입니다. 잘 만들어진 페이크 하나는 해당 API를 사용하는 수백, 수천 개의 테스트를 빠르고 안정적으로 만들어 조직 전체의 엔지니어링 속도를 크게 향상시킬 수 있습니다.

## 언제 페이크를 작성해야 하는가?
페이크는 실제 구현과 유사하게 동작해야 하므로 제작과 유지보수에 상당한 노력이 필요합니다. 따라서 다음과 같은 점을 고려해야 합니다.

소유권: 페이크는 실제 구현의 동작이 변경될 때마다 함께 업데이트되어야 합니다. 그렇기 때문에 실제 구현을 소유한 팀이 직접 페이크를 작성하고 유지보수하는 것이 가장 이상적입니다.

비용-편익 분석: 페이크를 작성하고 유지보수하는 비용보다, 그것을 사용함으로써 얻는 생산성 향상의 이점이 더 클 때 작성해야 합니다. 소수의 사용자만 있다면 가치가 적지만, 수백 명의 사용자가 있다면 명백한 생산성 향상을 가져올 수 있습니다.

작성 위치: 테스트가 어려운 의존성의 가장 근원적인 부분에 대해 페이크를 작성해야 합니다. 예를 들어, 데이터베이스 API를 직접 호출하는 모든 클래스에 대해 각각 페이크를 만드는 것이 아니라, 데이터베이스 API 자체에 대한 페이크를 하나만 만들어야 합니다.

### 페이크의 충실도 (The Fidelity of Fakes)
페이크를 만들 때 가장 중요한 개념은 충실도(Fidelity), 즉 페이크의 동작이 실제 구현의 동작과 얼마나 일치하는가입니다.

API 계약에 대한 충실도: 페이크가 모든 면에서 실제 구현과 100% 동일할 필요는 없습니다. 예를 들어, 페이크 데이터베이스는 성능이나 디스크 사용량까지 실제와 똑같이 모방할 필요는 없습니다. 하지만 API 계약(API contract)에 대해서는 완벽한 충실도를 유지해야 합니다. 즉, 동일한 입력에 대해 동일한 출력과 상태 변경을 보장해야 합니다.

테스트 관점에서의 충실도: 충실도는 테스트의 관점에서만 완벽하면 됩니다. 예를 들어, 해싱(hashing) API에 대한 페이크는 실제 구현과 정확히 동일한 해시값을 반환할 필요는 없습니다. 테스트는 보통 특정 해시값이 아닌, 입력에 따라 고유한 값이 반환된다는 사실 자체에만 관심이 있기 때문입니다.

지원되지 않는 기능: 페이크가 실제 구현의 모든 기능을 100% 구현할 필요는 없습니다. 만약 테스트가 페이크에서 지원하지 않는 코드 경로를 실행하려고 하면, 페이크는 조용히 무시하는 대신 **빠르게 실패(fail fast)**하여(예: 예외 발생) 해당 상황에 페이크가 적합하지 않음을 명확히 알려줘야 합니다.

### 페이크는 테스트되어야 한다 (Fakes Should Be Tested)
페이크 자체도 시간이 지남에 따라 실제 구현과 동작이 달라질 수 있습니다. 이를 방지하기 위해, 페이크 역시 자체적인 테스트를 가져야 합니다.

가장 좋은 접근법은 **'계약 테스트(contract tests)'**를 작성하는 것입니다. 이는 API의 공개 인터페이스에 대해 테스트 스위트를 작성한 뒤, 그 테스트를 실제 구현과 페이크 모두에 대해 실행하여 둘의 동작이 동일함을 보장하는 방식입니다.


### 스터빙 (Stubbing) 황용: 

스터빙은 테스트 내에서 특정 함수가 호출될 때 어떤 값을 반환할지 미리 정해주는(hardcoding) 기법입니다. 예를 들어, when(mockService.getTransactions()).thenReturn(listOfTransactions)와 같이 특정 메서드 호출에 대한 반환 값을 명시적으로 지정합니다.

### 스터빙 과용의 위험성
스터빙은 매우 편리하지만, 남용하면 다음과 같은 심각한 문제점을 야기합니다.

취약한 테스트 (Brittle Tests): 스터빙은 시스템의 내부 구현 세부사항(어떤 메서드를 호출하는지)을 테스트에 노출시킵니다. 이로 인해 운영 코드의 내부 로직이 리팩토링될 때마다, 실제 기능 변경이 없음에도 불구하고 수많은 테스트가 깨지게 됩니다.

불분명한 테스트 (Unclear Tests): 테스트 코드에 수많은 when(...).thenReturn(...) 구문이 포함되면, 테스트의 핵심적인 의도를 파악하기가 매우 어려워집니다.

비효율적인 테스트 (Less Effective Tests): 스터빙은 실제 구현의 동작을 보장하지 않습니다. stubCalculator.add(1, 2)가 3을 반환하도록 설정할 수는 있지만, 실제 Calculator가 그렇게 동작한다는 보장은 없습니다. 또한, 상태를 저장하지 않기 때문에 save() 호출 후 get()으로 상태를 확인하는 등의 테스트가 불가능합니다.

### 스터빙이 적절한 경우
스터빙은 실제 구현이나 페이크로는 만들기 어려운 특정 상태를 시뮬레이션해야 할 때 제한적으로 사용해야 합니다. 예를 들어, 드물게 발생하는 오류 조건을 재현하거나 특정 값을 반환해야만 다음 로직을 테스트할 수 있는 경우가 여기에 해당합니다. 하나의 테스트에서는 검증하려는 동작과 직접적으로 관련된 소수의 함수만 스터빙하는 것이 좋습니다.

### 상호작용 테스팅 (Interaction Testing)
상호작용 테스팅은 함수의 실제 구현을 실행하지 않고, 해당 함수가 어떻게 호출되었는지(호출 여부, 호출 횟수, 전달된 인자 등)를 검증하는 기법입니다. 이는 종종 '모킹(mocking)'이라고도 불립니다.

### 상태 테스팅을 우선하라 (Prefer State Testing)
구글에서는 상호작용 테스팅보다 **상태 테스팅(State Testing)**을 압도적으로 선호합니다.

상태 테스팅: 시스템의 최종 **결과(상태)**를 검증합니다. (예: numberSorter.sortNumbers()를 호출한 후 반환된 리스트가 정말로 정렬되었는지 확인)

상호작용 테스팅: 시스템이 결과를 만드는 과정을 검증합니다. (예: numberSorter.sortNumbers()가 내부적으로 quicksort.sort()를 호출했는지 확인)

상호작용 테스팅은 시스템이 올바르게 작동하는지 알려주는 것이 아니라, 단지 특정 함수가 예상대로 호출되었는지만을 알려줍니다. 이는 구현 세부사항에 의존하기 때문에 테스트를 매우 취약하게 만듭니다. 구글에서는 이러한 테스트를 **'변경 감지기 테스트(change-detector tests)'**라고 부르기도 합니다.

### 상호작용 테스팅이 적절한 경우
상호작용 테스팅은 다음과 같은 제한적인 상황에서 유용합니다.

상태를 검증할 방법이 없을 때: 실제 구현이나 페이크를 사용할 수 없어 상태 테스트가 불가능할 때, 최소한의 신뢰도를 확보하기 위한 차선책으로 사용될 수 있습니다.

상호작용 자체가 중요한 동작일 때: 예를 들어, 캐싱 기능이 실제로 데이터베이스 호출 횟수를 줄였는지 검증해야 할 때, 데이터베이스 객체가 특정 횟수 이하로 호출되었는지를 확인하는 것은 의미 있는 테스트입니다.


### 테스트 대역 활용법: 목(Mock) 제대로 쓰기: 

테스트 대역(Test Double)은 테스트 대상이 의존하는 객체를 대신하는 가짜 객체로, 대표적으로 스텁(Stub)과 목(Mock)이 있습니다.

스텁 (Stub): 테스트 중인 시스템에 값을 제공하는 역할(조회, Query)을 합니다. "외부 API를 호출하면 X라는 값을 반환해줘"와 같은 상황에 쓰입니다.

목 (Mock): 테스트 중인 시스템이 외부 시스템에 올바른 요청을 보내는지, 즉 나가는 상호작용을 검증하는 역할(명령, Command)을 합니다. "이메일 발송 메서드를 정확히 1번 호출했는지 확인해줘"와 같은 상황에 쓰입니다.
- 목의 가치를 극대화하는 가장 중요한 원칙은 시스템의 가장 끝단에서 목을 사용하는 것입니다. 예를 들어, UserController가 MessageBus를 통해 메시지를 보내고, MessageBus는 내부적으로 IBus 인터페이스를 래핑하여 실제 메시지를 전송한다고 가정해봅시다. 이때 MessageBus가 아닌, 실제 외부 시스템과 맞닿아 있는 IBus를 목으로 대체해야 합니다. 그 이유는 다음과 같습니다.
  - 더 넓은 코드 범위를 검증: IBus를 목킹하면 UserController부터 MessageBus의 내부 로직까지 모두 테스트에 포함되어 회귀 방지 효과가 커집니다.
  - 더 높은 리팩터링 내성: 시스템의 가장 끝단에 있는 어댑터(IBus)는 내부 로직(MessageBus)보다 변경될 확률이 훨씬 낮습니다. 따라서 테스트가 깨질 위험도 적습니다.
- 스파이(Spy)를 통한 명료한 검증: 스파이는 수동으로 만든 목으로, 호출 정보를 기록해 두었다가 검증에 활용합니다. 모킹 라이브러리를 사용하는 것보다 더 복잡한 상호작용을 명료하고 가독성 높게 검증할 수 있다는 장점이 있습니다.


## 개발 전/후 테스트 실행 절차 (LLM 필수)

- 목적: 기능 구현/리팩터링/버그 수정 전후로 테스트를 실행하여 베이스라인을 확보하고, 변경이 회귀를 유발하지 않았는지 즉시 검증한다. 본 절차는 사람이든 LLM이든 코드를 변경하는 모든 주체에 필수다.
- 사전 점검(변경 전)
  - 단위+통합 테스트를 모두 실행하되, 느린 테스트와 실제 외부 호출(`api`)은 제외한다.
    - 권장: `pytest -m "not slow and not api" -q`
    - 빠른 확인이 필요하면 임시로 단위 테스트만: `pytest -m "not slow and not api" -q` (PR 전에는 반드시 위 권장 커맨드 실행)
  - 결과를 기록한다: 실행 명령, 총 테스트 수, passed/failed/skipped/xfail, 실행 시간.

- 구현/수정 수행
  - 작은 단위로 커밋하고, 의미 있는 변경마다 테스트를 재실행한다.

- 사후 검증(변경 후)
  - 기본: `pytest -m "not slow and not api" -q`
  - 전체 스위트(느린/외부 API 포함)는 릴리스 직전이나 CI 주기적 작업에서 별도로 실행
  - PR 직전에는 반드시 전체 스위트(느린/외부 API 포함)를 한 번 이상 그린으로 만든다.
  - 결과 요약을 남긴다: 실행 명령, 통계(passed/failed/skipped 등), 소요 시간.

- 실패 대응(필수 보고 항목)
  - 실패한 테스트 파일/케이스 식별 및 관련 변경점 링크화.
  - 근본 원인 분석과 해결 방안 최소 3가지 제시 후, 채택안과 채택 이유 기록.
  - 수정 후 테스트를 재실행하고, 그린 확인 스냅샷(요약)을 첨부.
  - 금지: 테스트를 의도적으로 약화하거나, 목적 달성을 위해 테스트 코드를 임의 변경하는 행위.

- 자동화/에이전트 규칙
  - 이 문서를 따르는 에이전트(LLM 포함)는 코드 변경 전후 기본적으로 `pytest -m "not slow and not api" -q`를 실행해 결과를 수집·요약해야 한다. 성공/실패, 통계, 소요 시간을 명시한다. 추정으로 성공 처리 금지.
  - 필요한 경우 전체 스위트(느린/외부 API 포함)를 별도 단계로 실행·보고한다.

## 로깅/에러/성능

- 로깅: `loguru` 사용. 애플리케이션 경로별 핵심 이벤트(시작/종료/에러/분기)만 INFO 이상으로 남김
- 예외: `domain.exceptions`에 공용 예외 정의, 외부 라이브러리 예외는 래핑
- 성능: 배치 파이프라인은 배치 크기/동시성/재시도/백오프 파라미터를 노출하고 기본값은 보수적으로
- 멱등성: Upsert 키/상태 전이 정의. 재실행 시 부작용이 없도록 설계

## 작업 위치 결정 체크리스트

- 새 데이터 구조/프롬프트/스키마가 필요한가? → `src/domain/`
- 외부 서비스/DB/파일 시스템과 연동하는가? → `src/infrastructure/`
- 여러 단계를 묶는 유즈케이스/파이프라인인가? → `src/application/`
- 스케줄/의존성으로 태스크를 오케스트레이션해야 하는가? → `dags/`
- 사용자가 터미널에서 수동 실행할 진입점인가? → `scripts/`
- 검증/회귀 방지/계약 보장을 추가하는가? → `tests/`

## 네이밍/코드 스타일(요약)

- 함수/클래스/변수는 역할을 드러내는 풀네임 사용, 축약형 지양
- 가드 클로즈, 얕은 중첩, 명시적 타입힌트(Pydantic 모델은 필수 필드 명확화)
- 부수효과가 있는 코드는 `infrastructure`/`application`에만 배치
- 긴 함수 분리, SRP 준수. 공용 유틸은 해당 레이어에 국지화

## PR 체크리스트

- [ ] 변경 위치가 레이어 규칙에 부합하는가?
- [ ] `domain`이 프레임워크/환경에 오염되지 않았는가?
- [ ] 외부 호출이 `infrastructure`를 통해 이루어지는가?
- [ ] 유즈케이스 흐름/멱등성/에러 경계가 명확한가?
- [ ] 테스트(단위+필수 통합)가 핵심 계약을 검증하는가?
- [ ] 변경 전/후 테스트 실행 및 결과 요약을 PR에 포함했는가? (명령·통계·시간)
- [ ] 실패가 있었다면 근본 원인 분석과 최소 3가지 해결 방안을 비교·기록했는가?
- [ ] TDD로 테스트를 선 작성했는가? (GIVEN/WHEN/THEN, 초심자도 이해 가능한 주석/설명 포함)
- [ ] JSON 응답을 요구하는 프롬프트에 스키마와 "응답 예시(JSON)"를 명시했는가? (순수 JSON 규칙 포함)
- [ ] 로깅/설정/보안키 처리에 문제가 없는가?
- [ ] OWASP(The Open Web Application Security Project) TOP 10 보안 원칙을 벗어나지는 않는가? 

---

## 코드 컨벤션 for 엔터프라이즈 어플리케이션 개발을 위해서 

### 모듈화/구성
- 파일 크기: 한 파일 ≤ 300줄(권장 250줄), 함수 ≤ 20줄(권장 5줄), 클래스 한 책임(SRP). 함수도 하나의 일만(SRP)
- 복잡도: 함수 사이클로매틱 복잡도 ≤ 10(ruff C901), 중첩 ≤ 2–3레벨.
- 패키지 공개 API: __init__.py로 외부 노출 심플화, 내부 구현 숨김.
- 의미있는 네이밍: 약어 지양, 도메인 용어 기준.

### 아키텍처 경계
- 레이어 규칙 강제: domain ← application ← interface/dags/scripts, infrastructure는 domain에만 의존하도록 계약(contracts) 정의.
- 안정적 API/불안정 구현 분리: domain은 안정 인터페이스, infrastructure는 변동 구현. 교체·확장에 유리.
- 경계 DTO/모델 변환: interface에서 DTO 검증 및 application 경계에서 domain 모델로 변환.

### 예외/에러 모델
- 공통 예외 계층: domain.exceptions 중심으로 래핑. 외부 예외 노출 금지.
- 에러 응답 표준화: HTTP는 RFC7807, CLI는 일관된 종료코드·stderr 포맷.
- 리트라이/백오프: tenacity로 기본 정책(지수 백오프+지터, 최대 시도/타임아웃).

### 설정/비밀키
- 단일 설정 진입점: src/settings.py만 사용. 환경별 .env 분리(Dev/Stage/Prod).
- 비밀 관리: Vault/SM 연동 고려. 로그·예외에 비밀키 노출 금지.

### LLM 사용 규약

- 프롬프트/스키마 버전 관리: domain.prompts/domain.schemas에 버전 필드 포함.
- 출력 검증: 항상 Pydantic 검증 후 사용. 실패 시 폴백 경로 정의(다른 모델/프롬프트).
- 관찰성: 모델 ID, 프롬프트/응답 토큰, 비용 추정, 응답 시간, 성공률 메트릭화. PII는 마스킹/해시.
- 안전성: 프롬프트 인젝션 방지 룰, 외부 텍스트는 사전 정화(sanitizer) 통과.

#### Prompt 작성 시 JSON 구조화 응답 가이드(반드시 예시 포함)

- 원칙
  - JSON 응답을 요구하는 모든 프롬프트에는 응답 스키마(또는 필드 명세)와 "응답 예시(JSON)"를 반드시 포함한다.
  - 모델에게 "순수 JSON만 반환"을 명시한다. 코드블록 표기(```), 추가 설명, 프리앰블/포스트앰블 금지.
  - 필수 필드/타입/열거값(enum)/값 범위, `additionalProperties=false` 여부를 명확히 한다.

- 프롬프트 템플릿 예시
```text
당신은 도메인 규칙에 맞는 JSON을 생성하는 어시스턴트입니다.

출력 형식 요구사항:
- 반드시 순수 JSON만 반환하세요. 코드블록 표기(\"```\")나 설명 텍스트를 포함하지 마세요.
- 아래 스키마를 엄격히 준수하세요. 값 타입을 정확히 맞추고, 정의되지 않은 추가 필드는 포함하지 마세요.

스키마(JSON Schema):
{
  "type": "object",
  "properties": {
    "title": {"type": "string", "minLength": 1},
    "tags": {"type": "array", "items": {"type": "string"}},
    "confidence": {"type": "number", "minimum": 0, "maximum": 1}
  },
  "required": ["title", "tags", "confidence"],
  "additionalProperties": false
}

응답 예시(JSON):
{
  "title": "기후 변화가 해양 생태계에 미치는 영향",
  "tags": ["환경", "해양", "지속가능성"],
  "confidence": 0.87
}
```

- 검증/폴백
  - 응답은 `domain.schemas`의 Pydantic 모델로 검증한다. 실패 시 `infrastructure.llm.structured_output_manager`를 통해 재시도/폴백 전략을 적용한다.
  - 날짜/시간/통화 등 포맷이 필요하면 포맷 예시를 스키마와 함께 명시한다(예: ISO8601, 소수점 자리수 등).


### API/Interface 규약

- 버저닝: /v1 URI 또는 헤더 기반. 하위 호환 보존 기간 명시.
- 페이징/정렬: 커서 기반 권장, 기본 limit 상한. 일관 키 네이밍(page_token, page_size).
- 캐시/동시성: ETag/If-Match로 안전한 업데이트. Idempotency-Key 지원(POST).
- 보안 헤더/레이트 리밋: 표준 헤더 적용, DoS 최소치 보호선.

### Airflow 규약 
- DAG 명명/문서화: team_feature_pipeline 형태, doc_md 필수.
- XCom 최소화: 대형 페이로드 금지, 스토리지 경유. Task는 멱등/재시도 안전.
- 스케줄/재시도: 보수적 기본값, SLA·알림 설정. 동적 태스크 매핑은 모니터링 포함.

### 테스트 전략
- 피라미드: Unit(80%+)/Contract/Integration(15%)/E2E(5%). 외부 API는 계약 테스트+목.
- 테스트 데이터: 고정 픽스처/스냅샷 검증 신중 사용(과적합 주의). API 계약은 스키마 기반.
- 성능/회복력 테스트: 타임아웃/리트라이/대량 배치/경계값 포함.
- 유닛 테스트 (Unit Testing) 는 메소드가 아닌 행동(behavior)를 테스트하고 구현 세부사항이 아닌 공개 API 를 테스트해서 테스트 견고성을 높힘. 
- 테스트 코드에서는 반복을 피하는 DRY(Don't Repeat Yourself) 원칙보다 설명적이고 의미 있는 구문을 선호하는 DAMP(Descriptive And Meaningful Phrases) 원칙을 따르는 것이 좋음. 
- 테스트 더블 (Test Doubles): 테스트 더블은 실제 구현을 대체하여 빠르고 안정적인 테스트를 가능하게 함. 실제 구현체를 사용하는 것이 가장 좋고, 그 다음에는 실제 구현처럼 동작하지만 가벼운 페이크(Fake) 하며 상호작용을 검증하는 Mocking 은 가능한 지양(테스트를 취약하게 만드니)

## 코드 작성 규칙 

- 코드 생성 시, 항상 장기적인 유지보수성과 확장성을 최우선으로 고려하라. 일회성 편의를 위한 '똑똑한(clever)' 코드보다 단순하고 지속 가능한 코드를 선호하라.
- 새로운 코드를 작성하기 전에 항상 기존 솔루션을 재사용할 수 있는지 먼저 탐색하라. 불필요한 코드를 줄이고, 오래된 시스템은 적극적으로 폐기(deprecation)하여 코드베이스의 총비용을 낮추는 방향으로 제안하라
- 다른 개발자가 쉽게 읽고, 리뷰하고, 수정할 수 있는 명확한 코드를 생성하라. 변수명, 함수명 등을 명확하고 서술적으로 작성하라. 복잡한 로직보다는 단순하고 명시적인 로직을 선호하며, 주석과 문서를 통해 코드의 의도를 명확히 전달하라.
- 함수 내 구현에서는 추상화 수준을 통일하세요. (고수준의 로직과 저수준의 세부 구현이 섞여 있으면 안 됩니다.)
- 함수 인수는 0개가 가장 이상적이며, 1~2개를 넘지 않도록 노력해야 합니다. 3개 이상은 특별한 이유가 없는 한 피해야 합니다
- 부수 효과(Side Effects)를 만들지 마세요: 함수는 선언된 기능 외에 다른 상태를 변경해서는 안 됩니다. 상태를 변경하는 함수(Command)와 정보를 반환하는 함수(Query)를 명확히 분리하세요
- 단일 책임 원칙 (SRP) 준수: 클래스에 새로운 기능을 추가하라는 요청을 받으면, 먼저 기존 메서드들이 어떤 '액터'를 위해 존재하는지 분석하십시오. 만약 새로운 기능이 다른 액터(예: 회계팀 vs. 인사팀)를 위한 것이거나 다른 이유로 변경될 가능성이 있다면, 기존 클래스를 수정하는 대신 새로운 클래스를 생성하여 기능을 분리할 것을 제안하고 코드를 작성하십시오.
- 개방-폐쇄 원칙 (OCP) 준수: 새로운 동작을 추가해야 할 때, 기존 클래스의 코드를 직접 수정하는 if/else 또는 switch 문을 추가하는 대신, 추상화(인터페이스나 추상 클래스)를 사용하고 새로운 클래스가 그 추상화를 구현하도록 코드를 생성하십시오. 이를 통해 기존 코드를 변경하지 않고도 새로운 동작을 '플러그인'처럼 추가할 수 있습니다.
- 리스코프 치환 원칙 (LSP) 준수: 상속 구조를 생성할 때, 하위 클래스가 상위 클래스의 모든 메서드를 의미적으로 동일하게 수행할 수 있는지 확인하십시오. 만약 하위 클래스가 상위 클래스의 특정 메서드를 구현할 수 없거나(예: 예외를 던짐) 동작 방식이 다르다면, 상속 대신 다른 설계 패턴(예: 컴포지션)을 사용할 것을 제안하십시오.
- 인터페이스 분리 원칙 (ISP) 준수: 인터페이스를 생성할 때, 해당 인터페이스를 사용할 클라이언트의 역할에 초점을 맞추십시오. 만약 한 클라이언트가 인터페이스의 메서드 중 일부만 사용한다면, 인터페이스를 더 작은 역할 기반의 인터페이스들로 분리하여 생성하십시오.
- 의존성 역전 원칙 (DIP) 준수: 고수준 정책 모듈이 저수준 세부사항 모듈(예: 데이터베이스 접근 로직)의 기능을 호출해야 할 때, 고수준 모듈 내에 추상 인터페이스를 정의하십시오. 그리고 저수준 모듈이 이 인터페이스를 구현하도록 코드를 생성하십시오. 이렇게 하면 소스 코드 의존성이 항상 세부사항에서 정책으로 향하게 되어, 시스템의 핵심 로직이 외부 변화로부터 보호됩니다.
- 컴포넌트 응집도 (Cohesion) 준수: 기본적으로 공통 폐쇄 원칙 (CCP, 동일한 이유로, 동일한 시점에 변경되는 클래스들을 같은 컴포넌트로 묶어라. (유지보수성을 위한 원칙))를 우선하여 코드를 구성하십시오. 즉, 특정 기능(use case) 변경 시 함께 수정될 가능성이 높은 클래스들을 하나의 컴포넌트(예: Java 패키지)로 묶으십시오. 사용자가 명시적으로 '재사용 가능한 라이브러리' 생성을 요청할 경우에만 CRP(공통 재사용 원칙, 함께 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함시켜라.)와 REP(재사용/릴리스 등가 원칙, 재사용의 단위는 릴리스의 단위와 같다. (함께 재사용되는 클래스들은 같은 컴포넌트에 속해야 한다.))를 더 비중 있게 고려하십시오.
- 새로운 의존성을 추가할 때, 기존 의존성 그래프를 분석하여 순환이 발생하는지 확인하십시오. 만약 순환이 발생한다면, DIP를 적용하여 의존성을 역전시키거나, 공유되는 클래스를 새로운 컴포넌트로 분리하여 순환을 끊는 코드를 생성하십시오.
- 데이터베이스나 웹 프레임워크 같은 세부사항은 항상 가장 바깥쪽 계층에 위치시키고, 안쪽 계층은 이들이 정의한 추상 인터페이스(포트)를 통해서만 소통하도록 코드를 생성하십시오.
- 폴백(Fallback) 기능은 핵심 로직의 특정 예외 상황에서만 실행되도록 구현하세요. 사소한 오류로 인해 폴백이 불필요하게 실행되는 것을 방지할 수 있습니다.


