고가용성 확보 : Redis / Kafka / Flink 

---
독립적인 '워치독(Watchdog)' 프로세스: 주문 실행기와는 별개로, 주기적으로 업비트의 '미체결 주문 목록'과 '현재 보유 자산'을 조회하는 '감시자' 프로세스를 둡니다.
- 역할 1 (좀비 주문 처리): Flink가 매도 신호를 보냈는데, 주문 실행기의 장애로 실제 주문이 나가지 못하고 포지션이 남아있는 경우를 감지합니다. (e.g., Flink의 active_positions 상태와 실제 보유 자산 간의 불일치). 이 경우 워치독이 강제로 해당 포지션을 시장가로 청산합니다.
- 역할 2 (미아 주문 처리): 위 진입 로직에서 발생한 '미아 주문'을 감지하고 기록합니다.

---
Redis Circuit Breaker 도입

---

Lease Lock Processing 상태: 
-> 성공
-> 실패 
    -> 주문 전 실패
    -> 주문 중 실패 
        -> 거래 성공 (30초가 지나가버림)
        -> 거래 실패 
    -> 주문 후 실패
        -> Kafka 에 기록 성공 
        -> Kafka 에 기록 실패 

-> 복구 로직
    -> 업비트 API 에 identifier 를 담아서 주문 성공/실패를 확인한다. 
        -> kafka 에 중복 전송 가능 -> Transactional Producer 를 통해서 해결 가능 : 신호를 소비(Consume)하고, 처리(Process)하고, 결과를 발행(Produce)하는 전체 과정을 하나의 원자적(Atomic) 트랜잭션으로 묶는 것
    -> 재시도 
    -> 재시도 실패 -> dead letter queue 전송 

-> lease lock 은 30초 이내에만 재시도를 해볼 수 있다는거임. 문제는 항상 매도에 있음. (매수와 매도는 lock 시간이 다르도록?)
    -> dead letter queue 

30초 이내 장애 / 30초 이후 장애 
-> 

모든 장애 시나리오를 생각해보자. (크래쉬 / 네트워크 파티션 / 긴 GC로 인한 멈춤 / 실패)
- (1) 임시 잠금 실패 
- (2) 임시 잠금 성공 후 주문 실패 후 장애 
- (3) 임시 잠금 성공 후 주문 성공 후 메시지 발행 실패
- (4) 임시 잠금 성공 후 주문 성공 후 장애 
- (6) 임시 잠금 성공 후 주문 성공 후 장애 -> 복구 재개(업비트 멱등성 시간 만료) 
- (7) 업비트에서 장애가 발생한 경우 :-> Dead Letter Queue 
- (8) 복구 로직에서 메시지 중복 발행 :-> Transactional Producer 
- (9) 임시 잠금 후 긴 GC, 새로운 프로세스에서 복구로직 실행, 동시 주문 가능성 (복구로직은 필요없음.)

고려할 필터체인 
- 매수는 Safe try / 매도는 어떻게든 성공 
- 매수 신호가 와서 주문에 실패했는데, 매도 신호가 이어서 오는 경우. 
- 매도 주문이 계속해서 실패하는 경우 

--- 
system.events.v1 Kafka : 

각 서비스(Flink, Execution Engine 등)가 이벤트가 발생할 때마다 DB에 직접 쓰는 것은 비효율적이고 위험합니다. 대신, 각 서비스는 발생한 이벤트를 가벼운 메시지로 만들어 system.events.v1이라는 공통 Kafka 토픽으로 '발행(Publish)'만 하고 자신의 원래 업무를 계속합니다.

그리고 Archivist 서비스(또는 별도의 이벤트 로거 서비스)가 이 토픽을 구독(Subscribe)하여 system_events 테이블에 차곡차곡 쌓는 역할을 전담합니다.

