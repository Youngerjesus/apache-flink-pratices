고가용성 확보 : Redis / Kafka / Flink 

---
독립적인 '워치독(Watchdog)' 프로세스: 주문 실행기와는 별개로, 주기적으로 업비트의 '미체결 주문 목록'과 '현재 보유 자산'을 조회하는 '감시자' 프로세스를 둡니다.
- 역할 1 (좀비 주문 처리): Flink가 매도 신호를 보냈는데, 주문 실행기의 장애로 실제 주문이 나가지 못하고 포지션이 남아있는 경우를 감지합니다. (e.g., Flink의 active_positions 상태와 실제 보유 자산 간의 불일치). 이 경우 워치독이 강제로 해당 포지션을 시장가로 청산합니다.
- 역할 2 (미아 주문 처리): 위 진입 로직에서 발생한 '미아 주문'을 감지하고 기록합니다.

---
Redis Circuit Breaker 도입

---

Lease Lock Processing 상태: 
-> 성공
-> 실패 
    -> 주문 전 실패
    -> 주문 중 실패 
        -> 거래 성공 (30초가 지나가버림)
        -> 거래 실패 
    -> 주문 후 실패
        -> Kafka 에 기록 성공 
        -> Kafka 에 기록 실패 

-> 복구 로직
    -> 업비트 API 에 identifier 를 담아서 주문 성공/실패를 확인한다. 
        -> kafka 에 중복 전송 가능 -> Transactional Producer 를 통해서 해결 가능 : 신호를 소비(Consume)하고, 처리(Process)하고, 결과를 발행(Produce)하는 전체 과정을 하나의 원자적(Atomic) 트랜잭션으로 묶는 것
    -> 재시도 
    -> 재시도 실패 -> dead letter queue 전송 

-> lease lock 은 30초 이내에만 재시도를 해볼 수 있다는거임. 문제는 항상 매도에 있음. (매수와 매도는 lock 시간이 다르도록?)
    -> dead letter queue 

30초 이내 장애 / 30초 이후 장애 
-> 

모든 장애 시나리오를 생각해보자. (크래쉬 / 네트워크 파티션 / 긴 GC로 인한 멈춤 / 실패)
- (1) 임시 잠금 실패 
- (2) 임시 잠금 성공 후 주문 실패 후 장애 
- (3) 임시 잠금 성공 후 주문 성공 후 메시지 발행 실패
- (4) 임시 잠금 성공 후 주문 성공 후 장애 
- (6) 임시 잠금 성공 후 주문 성공 후 장애 -> 복구 재개(업비트 멱등성 시간 만료) 
- (7) 업비트에서 장애가 발생한 경우 :-> Dead Letter Queue 
- (8) 복구 로직에서 메시지 중복 발행 :-> Transactional Producer 
- (9) 임시 잠금 후 긴 GC, 새로운 프로세스에서 복구로직 실행, 동시 주문 가능성 (복구로직은 필요없음.)

고려할 필터체인 
- 매수는 Safe try / 매도는 어떻게든 성공 
- 매수 신호가 와서 주문에 실패했는데, 매도 신호가 이어서 오는 경우. 
- 매도 주문이 계속해서 실패하는 경우 

--- 
system.events.v1 Kafka : 

각 서비스(Flink, Execution Engine 등)가 이벤트가 발생할 때마다 DB에 직접 쓰는 것은 비효율적이고 위험합니다. 대신, 각 서비스는 발생한 이벤트를 가벼운 메시지로 만들어 system.events.v1이라는 공통 Kafka 토픽으로 '발행(Publish)'만 하고 자신의 원래 업무를 계속합니다.

그리고 Archivist 서비스(또는 별도의 이벤트 로거 서비스)가 이 토픽을 구독(Subscribe)하여 system_events 테이블에 차곡차곡 쌓는 역할을 전담합니다.

--- 
Reconcilation Job 에 Restore(복원) 뿐 아니라 Clear(지우기) 까지 포함 
- “살리기(restore)”만이 아니라 “지우기(clear)”도 필요합니다. 피드백 지연/유실, 코드 버그로 Flink에 포지션이 남을 수 있으니까요. 다만 두 동작은 목적과 증거 기준이 다르므로 명령을 분리해야 안전합니다.

- 왜 분리?
  - Restore: “DB엔 OPEN인데 Flink엔 없음” → 포지션 복원
  - Clear: “DB엔 CLOSED인데 Flink엔 있음” → 포지션 정리
  - 혼합하면 현재 유효 상태를 과거 정보로 덮어쓰는 사고가 납니다.

Clear(지우기) 발행 조건(Rec Job, 보수적)
- 증거 다중 검증 모두 충족 시에만 발행
  - trades에 SELL SUCCESS 존재(원 신호/사이클 매칭)
  - trade_cycles가 해당 entry_signal_id로 CLOSED
  - 이후 BUY 신호/거래 재진입 없음(재개 진입과 충돌 방지)
  - Archivist DB 지연 워터마크 정상(임계 미만), 아니라면 보류
  - 최근 5–10초 내 상태 전이 이벤트(SELL 신호 등)와 충돌 없음
- 멱등성/중복 억제: (code, entry_signal_id) 기준 TTL dedup + 재시도 백오프
- 신선도 제한: clear_timestamp가 너무 오래된 명령은 버림

Flink 수신 측 처리(안전 게이트)
- ClearCommand
  - active_positions에 해당 code가 없으면: no-op(멱등)
  - active 있고 entry_signal_id 일치: remove + recently_removed TTL 기록
  - active 있지만 entry_signal_id 불일치: 무시(이미 재진입했을 가능성, 현재 사실 보호)
  - 명령 신선도 초과: 무시
- RestoreCommand
  - recently_removed에 같은 ID 있으면: stale → 거부
  - active 존재하면: 어떤 복원도 거부(현재 사실 보호)
  - 신선도/증거 검증 통과 시에만 put

권장 메시지 분리
- StateRestoreCommand(code, position_info, restore_reason, restore_timestamp)
- StateClearCommand(code, entry_signal_id, clear_reason, clear_timestamp)

원칙
- 확신 불가 땐 no-op가 안전하다.
- “현재 유효 상태 보호(active 우선) + 과거 증거 기반으로만 정리/복원” 조합이 레이스·지연·리플레이 모두에 견고하다.

---
Ghost Positions (유령 포지션)의 존재할 가능성이 있는지 파악해봐야함. 

--- 
네, 알겠습니다. 매수/매도 양쪽에 `PENDING` 상태를 도입하여 시스템의 안정성을 한 단계 끌어올리는 작업 제안을 문서 형식으로 정리해 드리겠습니다. 이 내용을 나중에 `추후 과제.md`나 새로운 설계 문서에 붙여넣으시면 됩니다.

---
### **[작업 제안] Flink 포지션 상태 머신(State Machine) 도입을 통한 정합성 및 안정성 강화**

**1. 배경 및 문제 제기**

현재 아키텍처는 매수/매도 신호 발생 시 Flink의 내부 상태(`active_positions`)를 즉시 변경하거나, 피드백을 기다리더라도 그 과정이 단순하게 설계되어 있습니다. 이는 빠른 MVP 개발에는 유리하지만, 실제 운영 환경에서 발생할 수 있는 다음과 같은 치명적인 엣지 케이스에 취약합니다.

*   **문제 1: 매수 실패 시 '유령 포지션' 발생**
    *   **시나리오:** Flink가 매수 신호를 발행하고 `active_positions`에 포지션을 `OPEN`으로 기록했지만, 주문 실행 계층에서 일시적인 API 오류로 실제 주문은 실패하는 경우.
    *   **결과:** Flink는 포지션을 보유하고 있다고 착각하여 매도 로직만 주시하게 됩니다. 실제 자산은 없는데도 Flink의 자금은 영원히 묶이고, 동일 코인에 대한 새로운 매수 기회를 모두 놓치게 됩니다.

*   **문제 2: 매도 실패 시 '영구 동결 포지션' 발생**
    *   **시나리오:** Flink가 active_positions 에서 해당 포지션을 제거하고 매도 신호를 보냈지만, 주문 실행이 실패하고 Flink가 `FAILED` 피드백을 제대로 처리하지 못하는 경우.
    *   **결과:** 포지션은 영원히 유령 상태에 머물게 되어,  Flink는 추가적인 매도 신호를 생성할 수 없습니다. 이는 직접적인 자산 손실로 이어질 수 있습니다.

이 문제들의 근본 원인은 Flink의 상태 변경이 **실제 세계(거래소 체결)의 최종 결과를 확인하기 전에** 잠정적으로 이루어지기 때문입니다.

**2. 제안: 명시적인 상태 머신(State Machine) 도입**

`PositionInfo` 내에 명확한 상태(Status)를 정의하고, 신호 발생과 피드백 수신에 따라 상태가 전이되는 정교한 상태 머신을 도입할 것을 제안합니다.

*   **신규 상태 정의**
    *   `PENDING_OPEN`: 매수 신호가 발행되었고, 체결 성공 피드백을 기다리는 상태.
    *   `OPEN`: 매수 체결이 최종 확인되어, 매도 기회를 탐색 중인 안정된 활성 상태.
    *   `PENDING_CLOSE`: 매도 신호가 발행되었고, 체결 성공 피드백을 기다리는 상태.

**3. 상세 설계**

**3.1. 상태 전이 다이어그램**

```
           BUY 신호
 (None) ──────────> PENDING_OPEN ─────┬──> (None) [제거]
                        │              │    (BUY 실패 피드백)
                        │              │
                        ▼              │
                  (BUY 성공 피드백)      │
                        │              │
                        ▼              │
SELL 신호                OPEN ───────────┘
     │                  ▲
     │                  │ (SELL 실패 피드백)
     ▼                  │
PENDING_CLOSE ───────────┴──> (None) [제거]
                              (SELL 성공 피드백)
```

**3.2. `position_info.proto` 스키마 확장**

`PositionInfo`가 자신의 상태와 진행 중인 매도 신호 ID를 추적할 수 있도록 필드를 추가합니다.

```proto
// PositionInfo의 내부 상태
enum PositionStatus {
  POSITION_STATUS_UNSPECIFIED = 0;
  PENDING_OPEN = 1;  // 진입 대기
  OPEN = 2;          // 활성 (매도 탐색)
  PENDING_CLOSE = 3; // 청산 대기
}

message PositionInfo {
  string entry_signal_id = 1;
  SignalReason entry_reason = 2;
  double entry_price = 3;
  google.protobuf.Timestamp entry_timestamp = 4;
  PositionStatus status = 5;                // [추가] 포지션의 현재 상태
  string pending_exit_signal_id = 6;      // [추가] 진행 중인 매도 신호 ID
}
```

**3.3. Flink `CoProcessFunction` 로직 수정 (의사 코드)**

*   **매수 신호 생성 로직 (`process_element1` 또는 `2`)**
    *   IF (매수 조건 충족) AND (`active_positions`에 해당 `code`가 없음):
        1.  매수 신호(`buy_signal`)를 발행합니다.
        2.  `PositionInfo` 객체를 `status=PENDING_OPEN`, `entry_signal_id=buy_signal.signal_id`로 생성합니다.
        3.  `active_positions.put(code, new_position_info)`로 상태를 저장합니다.
        4.  (필수) 피드백 유실에 대비해 **타임아웃 타이머**(e.g., 3초)를 등록합니다. 타이머가 울렸을 때 여전히 `PENDING_OPEN` 상태라면, 주문이 실패했다고 간주하고 포지션을 제거합니다.

*   **매도 신호 생성 로직 (`process_element1` 또는 `2`)**
    *   `position_info = active_positions.get(code)`
    *   IF (`position_info`가 존재) AND (`position_info.status == OPEN`) AND (매도 조건 충족):
        1.  매도 신호(`sell_signal`)를 발행합니다.
        2.  `position_info.status`를 `PENDING_CLOSE`로 변경합니다.
        3.  `position_info.pending_exit_signal_id`를 `sell_signal.signal_id`로 설정합니다.
        4.  `active_positions.put(code, position_info)`로 업데이트합니다.

*   **피드백 처리 로직 (`process_element3`)**
    ```python
    def process_element3(self, feedback: ExecutionFeedback, ctx):
        position_info = self.active_positions.get(feedback.code)
        if not position_info: return

        # === 매수 피드백 처리 ===
        if position_info.status == PositionStatus.PENDING_OPEN and feedback.signal_id == position_info.entry_signal_id:
            if feedback.status == "SUCCESS":
                # 매수 확정. OPEN 상태로 전이하여 매도 로직 활성화
                position_info.status = PositionStatus.OPEN
                self.active_positions.put(feedback.code, position_info)
                # 등록했던 타임아웃 타이머를 삭제
            elif feedback.status in ["FAILED", "TIMEOUT"]:
                # 매수 실패. 포지션 완전 제거
                self.active_positions.remove(feedback.code)
                # (선택) recently_removed에 기록하여 짧은 시간 내 Stale 복원 방지

        # === 매도 피드백 처리 ===
        elif position_info.status == PositionStatus.PENDING_CLOSE and feedback.signal_id == position_info.pending_exit_signal_id:
            if feedback.status == "SUCCESS":
                # 매도 확정. 포지션 완전 제거
                self.active_positions.remove(feedback.code)
                self.recently_removed_positions.put(...) # Stale 복원 방지
            elif feedback.status in ["FAILED", "TIMEOUT"]:
                # 매도 실패. 다시 매도 기회를 탐색하도록 OPEN 상태로 롤백
                position_info.status = PositionStatus.OPEN
                position_info.pending_exit_signal_id = ""
                self.active_positions.put(feedback.code, position_info)

    ```

**4. 기대 효과**

*   **정합성 대폭 향상:** Flink의 상태가 실제 거래소의 체결 상태와 거의 실시간으로 일치하게 됩니다.
*   **자동 복구 능력 확보:** 주문 실패(매수/매도) 시 Flink가 스스로 상태를 되돌려, 수동 개입 없이도 다음 기회를 정상적으로 포착할 수 있게 됩니다.
*   **안정성 강화:** '유령 포지션'과 '영구 동결 포지션' 발생을 원천적으로 차단하여 자산을 보호합니다.
*   **로직 명확성:** 각 상태에서 수행할 수 있는 작업이 명확해져 코드의 가독성과 유지보수성이 향상됩니다.

**5. 결론**

본 제안은 단순한 기능 개선을 넘어, 시스템을 이벤트에 단순히 반응하는 수준에서 자신의 행동 결과를 책임지고 확인하는 **'능동적이고 신뢰성 있는 에이전트'**로 격상시키는 핵심적인 아키텍처 변경입니다. 프로덕션 환경의 안정적인 운영을 위해 반드시 필요한 작업입니다.
