# CEP Layer - 실제 구현 설계 및 체크리스트

## 1. 프로젝트 구조 설계 

complex_event_processing Layer/
ㄴ applicaiton
ㄴ domain
    ㄴ models/signal_reason.py
    ㄴ models/position_info.py
    ㄴ algorithms/calculate_density_change_rate.py
    ㄴ models/generate_deterministic_signal_id/py 
ㄴ infrastructure
ㄴ interface 

## 2. Domain Layer 

### 2.1 models/signal_reason.py (신호와 상태 모델 정의)

코드 스니펫(일부)
```python
    class SignalReason(Enum):
        """ 매매 신호가 발생한 구체적인 비즈니스 규칙(전략) """
        REASON_UNSPECIFIED = 0 # Protobuf 호환성을 위한 기본값
        
        # --- 매수 신호 (Entry Signals) ---
        P_WAVE_EARTHQUAKE_DETECTED = auto()
    
        # --- 매도 신호 (Exit Signals) ---
        AFTERSHOCK_WAVE_DECAY = auto()
        
        # --- 기타 (리스크 관리 등) ---
        STOP_LOSS_TRIGGERED = auto()
```

역할 : 매수/매도 신호가 발생한 이유 전략을 말함(P파에 걸렸다, Aftershock 에 걸렸다 등) 

체크리스트: 
- [ ] enum 표준 라이브러리의 Enum과 auto를 임포트한다.
- [ ] 아키텍처 문서에 명시된 모든 신호 이유(e.g., P_WAVE_EARTHQUAKE_DETECTED, AFTERSHOCK_WAVE_DECAY)를 멤버로 정의한다.
- [ ] 각 멤버의 값은 auto()를 사용하여 자동으로 할당되도록 하여, 값 자체에 의미를 부여하지 않는다.

---
### 2.2 models/position_info.py

코드 스니펫 일부: 
```python
    from dataclasses import dataclass
    from datetime import datetime
    from decimal import Decimal
    from .enums import SignalReason

    @dataclass(frozen=True)
    class PositionInfo:
        """ Flink의 Keyed State에 저장될 활성 포지션 정보 """
        entry_signal_id: str
        entry_reason: SignalReason
        code: str
        entry_price: Decimal
        entry_timestamp: datetime
        volume: Decimal
```

역할: 현재 보유중인 포지션 정보를 나타냄 

체크리스트: 
- [ ] dataclasses 라이브러리를 사용하여 PositionInfo 클래스를 정의한다.
- [ ] @dataclass(frozen=True) 데코레이터를 사용하여 불변(immutable) 객체로 만든다.
- [ ] entry_signal_id, code는 str 타입으로 정의한다.
- [ ] entry_price, volume 등 금융 관련 값은 Decimal 타입을 사용하여 부동소수점 오류를 방지한다.
- [ ] entry_reason은 위에서 정의한 SignalReason Enum 타입으로 정의한다.
- [ ] entry_timestamp는 datetime 타입으로 정의한다.
- 가격/수량 필드가 float이 아닌 Decimal 타입으로 정의되었는지 검증.
- 필드명이 아키텍처 문서 및 Protobuf 스키마와 일치하는지 교차 검증.

---
### 2.3 algorithms/calculate_density_change_rate.py 

역할: P파 감지를 위한 핵심 전조 증상인 '호가 밀도 변화율' 계산 

체크리스트: 
- [ ] Flink 시스템에 의존적이지 않은 순수 함수인가? 
- [ ] 모든 금융 계산은 Decimal 타입을 사용한다.
- [ ] recent_ask_volumes 리스트에서 window_seconds 내에 포함되는 데이터만 필터링하는 로직을 구현한다.
- 충분한 데이터가 없거나 평균이 사실상 0이면 “신호 보류(warm-up)” 처리
- 평균 대비 증가(음수)도 그대로 반환 (변화를 있는 그대로 판단(매도벽 두꺼워지기, 얇아지기 등을 음수/양수로 그대로 판단)) -> 정확한 계산 가능 

핵심 코드 스니펫
```python
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timedelta
from decimal import Decimal, ROUND_HALF_UP, getcontext
from typing import Iterable, Optional, Sequence, Tuple

getcontext().prec = 28  # 전략 전체에서 사용하는 기본 정밀도와 일치시킴


@dataclass(frozen=True)
class DensityChangeMetrics:
    rate_pct: Decimal        # (1 - current / baseline) * 100 결과
    baseline: Decimal        # 평균 매도 총량
    sample_count: int        # 윈도우 내 유효 샘플 개수
    coverage_seconds: Decimal
    is_warmup: bool          # 기준 부족으로 아직 판단 보류인지 여부

def in_warmup(first_seen_ts, now, sample_count, warmup_seconds, min_samples):
    warmup_elapsed = (now - first_seen_ts).total_seconds()
    return warmup_elapsed < warmup_seconds or sample_count < min_samples

def calculate_orderbook_density_change(
    current_total_ask_size: Decimal,
    recent_ask_volumes: Sequence[Tuple[datetime, Decimal]],
    now: datetime,
    window_seconds: int,
    first_seen_ts: datetime,
    warmup_seconds: int = 30,
    min_samples: int = 10,
) -> DensityChangeMetrics:
    window_start = now - timedelta(seconds=window_seconds)
    samples = [(ts, vol) for ts, vol in recent_ask_volumes if window_start <= ts <= now]
    sample_count = len(samples)

    if not samples:
        return DensityChangeMetrics.zero(is_warmup=True)

    baseline = sum(vol for _, vol in samples) / Decimal(sample_count)
    if baseline == 0:
        return DensityChangeMetrics.zero(is_warmup=True)

    if in_warmup(first_seen_ts, now, sample_count, warmup_seconds, min_samples):
        return DensityChangeMetrics(
            rate_pct=Decimal("0"),
            baseline=baseline,
            sample_count=sample_count,
            coverage_seconds=Decimal((now - samples[0][0]).total_seconds()),
            is_warmup=True,
        )

    rate = Decimal("1") - (current_total_ask_size / baseline)
    rate_pct = (rate * Decimal("100")).quantize(Decimal("0.0001"), rounding=ROUND_HALF_UP)

    return DensityChangeMetrics(
        rate_pct=rate_pct,
        baseline=baseline,
        sample_count=sample_count,
        coverage_seconds=Decimal((now - samples[0][0]).total_seconds()),
        is_warmup=False,
    )
```

---
### 2.4 generate_deterministic_signal_id 함수

역할 : Flink 재처리시에 동일한 ID 를 생성할 수 있도록 멱등성을 부여하는 역할 

구현 체크리스트:
- [ ] ID 생성에 필요한 모든 요소(code, side, reason, timestamp 등)를 인자로 받도록 함수를 정의한다.
- [ ] 모든 입력 요소를 조합하여 일관된 문자열을 생성한다.
- [ ] 생성된 문자열에 hashlib.sha256과 같은 안정적인 해시 함수를 적용한다.
- [ ] 해시 결과를 hexdigest()로 변환하여 최종 ID 문자열을 반환한다.

---
### 2.5 PositionRemovalInfo 


---
### 2.6 trading_signal 


---
### 2.7 Other Domain Models 



---
## 3. Application Layer 

### 3.1 SignalGeneratorWithFeedback / CoProcessFunction 

역할 : 시스템의 핵심 두뇌를 담당(체결, 호가, 피드백, 복원) 등을 받음. 마켓 코드(code) 별로 상태를 관리. 도메인 규칙에 따라 매매 신호를 생성함. 주문 체결에 따라 동기화도 함. 

#### 3.1.1 상태 초기화 로직 

역할: Flink Job이 시작되거나 재시작될 때, 필요한 모든 상태 저장소를 선언하고 초기화합니다. 특히 recently_removed_positions 상태에 TTL(Time-To-Live)을 설정하여 메모리 누수를 방지하고 'Stale 복원 명령'을 막는 안전장치를 마련합니다.

체크리스트: 
- [ ] CoProcessFunction을 상속받는 클래스를 정의하고 open 메소드를 오버라이드한다.
- [ ] active_positions 상태를 MapStateDescriptor를 사용하여 선언한다. (Key: str, Value: PositionInfo)
- [ ] StateTtlConfig를 사용하여 30초 TTL 설정을 생성한다. (UpdateType.OnCreateAndWrite, StateVisibility.NeverReturnExpired)
- [ ] 생성된 TTL 설정을 MapStateDescriptor에 적용하여 recently_removed_positions 상태를 선언한다. (Key: str, Value: PositionRemovalInfo)
- [ ] last_orderbook_state (ValueState), recent_ask_volumes_state (ListState) 등 분석에 필요한 다른 상태들도 선언한다.

#### 3.1.2 시장 데이터 처리 로직 (process_element1, process_element2)

역할: 보강된 체결(Trade) 및 호가(OrderBook) 데이터를 받아, 현재 상태와 결합하여 도메인 규칙을 실행하고, 조건 충족 시 매매 신호를 생성하거나 상태를 업데이트합니다.

체크리스트: 
- [ ] process_element1 (Trade 처리), process_element2 (OrderBook 처리) 메소드를 구현한다.
- [ ] (매수 로직) active_positions에 현재 code에 대한 포지션이 없을 때 매수 신호 생성 로직을 실행한다. 명시적인 메인 스트림: SignalGeneratorWithFeedback 함수의 반환 타입을 TradingSignal로 명확히 정의. 
- [ ] last_orderbook_state, recent_ask_volumes_state 등에서 필요한 과거 데이터를 조회한다.
- [ ] 조회한 상태 데이터와 현재 수신된 데이터를 인자로 하여 domain.rules의 순수 함수들(e.g., calculate_density_change_rate)을 호출한다.
- [ ] 도메인 함수의 반환값이 설정된 임계치를 넘는지 확인하여 최종적으로 신호 생성 여부를 결정한다.
- [ ] (상태 업데이트) 매수 신호 생성 시, domain.rules.generate_deterministic_signal_id를 호출하여 ID를 만들고, PositionInfo 객체를 생성하여 active_positions 상태에 저장한다.
- [ ] (매도 로직) active_positions에 포지션이 있을 때 매도 신호 생성 로직을 실행한다.
- [ ] 매도 신호 생성 시, active_positions에서 해당 포지션을 remove()하고, recently_removed_positions에 put()하여 제거 기록을 남긴다.
- [ ] event_timestamp(원본 데이터 발생 시간)을 이벤트 시간으로 취급해야하며, 워터마크는 쓰지않음. 늦게 도착한 시간은 기회를 놓쳐버린 것으로 간주. 
- [ ] warmup 사용(초기엔 평균(베이스라인)이 비거나 0에 가까워 변화율이 과도(폭증/발산)하게 나와 오탐을 유발 가능하므로) / warmup 의 로직은 단순화를 위해 WARMUP_SEC 동안 적용. 
- 도메인 규칙 함수를 호출할 때, Flink 상태 객체 자체가 아닌 상태에서 꺼낸 '값'을 인자로 전달하는가? (도메인 계층의 순수성 유지) (P파 탐지 및 여진(파도 소멸) 는 순수 함수여야함.)


#### 3.1.3 상태 동기화 로직 (process_element3, process_element4)

역할: 외부 시스템(주문 실행 계층, Reconciliation Job)으로부터 오는 피드백과 복원 명령을 처리하여, Flink의 내부 상태를 외부의 '사실'과 일치시킵니다. 시스템의 안정성과 최종 일관성을 보장하는 핵심 로직입니다.

구현 체크리스트:
- [ ] process_element3 (피드백 처리), process_element4 (복원 명령 처리) 메소드를 구현한다.
- [ ] (피드백 처리) FAILED 또는 TIMEOUT 상태의 피드백을 수신했을 때 로직을 실행한다.
- [ ] active_positions에서 현재 포지션 정보를 조회하고, 피드백의 signal_id와 상태의 entry_signal_id가 일치하는지 반드시 검증한다. (Stale 피드백 방지) 
- [ ] ID가 일치하면, active_positions에서 포지션을 제거하고 recently_removed_positions에 기록한다.
- [ ] (복원 명령 처리) 복원 명령 수신 시, recently_removed_positions에 해당 code에 대한 제거 기록이 있는지 먼저 확인한다. 
- [ ] 제거 기록이 있다면, 이는 'Stale 복원 명령'이므로 무시하고 로그를 남긴다.
- [ ] 제거 기록이 없다면, active_positions에 이미 해당 포지션이 있는지 다시 한번 확인하고, 없을 경우에만 복원 명령의 PositionInfo를 active_positions에 put()하여 상태를 복원한다.
-  Stale 피드백 검증 로직이 누락되지 않았는가? if position_info and position_info.entry_signal_id == feedback.signal_id: 이 조건문은 시스템 안정성의 핵심입니다.
- Stale 복원 명령 방어 로직이 이중으로 되어있는가? recently_removed_positions 확인(1차 방어)과 active_positions 존재 여부 확인(2차 방어)이 모두 구현되었는지 검증합니다.
- 상태를 변경하는 모든 로직(remove, put)이 로그를 남겨서, 사후 추적이 용이하도록 되어 있는가?