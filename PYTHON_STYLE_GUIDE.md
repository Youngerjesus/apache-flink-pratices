### 특별 메서드를 직접 호출하지 마세요.

my_object.__len__() 대신 len(my_object)를 사용하세요. 내장 함수를 사용하는 것이 더 관용적일 뿐만 아니라, C로 구현된 내장 타입의 경우 훨씬 더 빠릅니다. 내장 함수는 해당 특별 메서드를 호출해 주는 동시에 다른 부가 서비스도 제공합니다. 특별 메서드는 우리가 직접 호출하기보다는, 구현하는 데 더 집중해야 합니다.

### __repr__을 먼저 구현하세요.

모든 파이썬 객체는 자신을 문자열로 표현하는 두 가지 표준적인 방법을 가집니다. 바로 repr()과 str() 내장 함수에 대응하는 __repr__()과 __str__() 특별 메서드입니다.

만약 두 가지 문자열 표현 중 하나만 구현해야 한다면, 단연코 __repr__을 선택해야 합니다. __str__이 구현되어 있지 않으면, str() 내장 함수는 __repr__의 결과를 대신 사용합니다. 따라서 __repr__만 잘 구현해두면 기본적인 문자열 표현은 보장됩니다. 유용한 __repr__이 없는 객체는 디버깅을 매우 어렵게 만듭니다.

### 연산자는 새로운 객체를 반환해야 합니다.

__add__나 __mul__ 같은 중위 연산자(infix operator) 특별 메서드는 피연산자를 수정해서는 안 됩니다 (self나 other를 변경하지 말아야 합니다). 대신, 연산 결과를 담은 새로운 객체를 생성하여 반환하는 것이 규칙입니다. += 같은 제자리(in-place) 연산자만이 self를 수정할 수 있습니다.

### 명시적인 것이 암시적인 것보다 낫습니다

파이썬에서는 모든 객체가 if나 while문과 같은 불리언 문맥에서 사용될 수 있습니다. 기본적으로 사용자 정의 클래스의 인스턴스는 항상 True로 간주됩니다. 하지만 객체의 내용에 따라 True나 False를 반환하도록 이 동작을 직접 제어할 수 있습니다

__len__()을 통해 암시적으로 참/거짓이 결정되게 하기보다는, __bool__()을 명시적으로 구현하여 객체의 진리값을 결정하는 의도를 명확히 드러내는 것이 더 파이썬다운 접근 방식입니다.

### 리스트 컴프리헨션을 현명하게 사용하세요

리스트 컴프리헨션의 목적은 항상 새로운 리스트를 만드는 것입니다. 만약 만들어진 리스트를 사용하지 않고 단순히 부수 효과(side effect)만을 위해 코드를 반복 실행하는 용도라면 이 구문을 남용하는 것입니다. 또한, 컴프리헨션이 두 줄을 넘어갈 정도로 길어진다면 가독성을 위해 일반 for 루프로 작성하는 것이 더 나을 수 있습니다.

### 중첩 리스트는 컴프리헨션으로 만드세요.

리스트에 곱셈 연산자 *를 사용하면, 리스트 안의 아이템 자체가 아닌 아이템에 대한 참조를 복사합니다.

이런 문제를 피하는 가장 좋은 방법은 리스트 컴프리헨션을 사용하는 것입니다. 컴프리헨션은 루프가 돌 때마다 새로운 내부 리스트를 생성하므로, 모든 행이 독립적인 객체가 됩니다.

### key와 reverse 인자 활용

두 방법 모두 key와 reverse라는 키워드 전용 인자를 받습니다. key 인자에는 각 아이템에 적용할 함수를 전달하여 정렬 기준을 바꿀 수 있습니다. 파이썬의 정렬 알고리즘은 **안정적(stable)**이므로, key 함수의 결과값이 같은 아이템들은 원래의 상대적 순서를 유지합니다.

### 리스트가 정답이 아닐 때

list는 매우 유연하고 편리하지만, 모든 상황에 최적인 것은 아닙니다. 특정 요구사항에 따라 더 나은 대안들이 있습니다.

array.array: 수치 데이터의 대규모 시퀀스를 다룰 때 사용합니다. list가 파이썬 객체에 대한 참조를 저장하는 반면, array는 C의 배열처럼 원시적인 숫자 값을 직접 저장하여 훨씬 더 적은 메모리를 사용합니다.

collections.deque: 양쪽 끝에서 아이템을 빠르게 추가하거나 삭제해야 할 때 이상적입니다. list에서 l.pop(0)나 l.insert(0, v)는 리스트의 모든 요소를 이동시켜야 하므로 매우 비효율적인 반면, deque는 양방향에서 O(1)의 성능을 보입니다.

set (집합): 시퀀스는 아니지만, 컬렉션에 특정 아이템이 포함되어 있는지 여부를 자주 확인해야 할 때 list보다 훨씬 뛰어난 성능을 보입니다. 이에 대해서는 다음 주제인 딕셔너리와 집합에서 자세히 다룰 것입니다.

### for 루프보다 리스트컴프를 선호하라

for 루프는 리스트 생성 외에도 합계 계산, 항목 필터링 등 다양한 작업을 수행할 수 있습니다. 반면, 리스트 컴프리헨션은 **"새로운 리스트를 만든다"**는 단 하나의 명확한 목적을 가집니다.  이처럼 의도를 명시적으로 드러내는 것이 더 읽기 좋은 코드를 만듭니다.

### map과 filter보다 리스트컴프가 낫다

리스트 컴프리헨션은 map과 filter 함수의 조합을 더 간결하고 가독성 높게 대체할 수 있습니다

### 리스트컴프를 남용하지 마라

리스트 컴프리헨션의 목적은 항상 새로운 리스트를 만드는 것입니다. 만약 만들어진 리스트를 사용하지 않고 단순히 부수 효과(side effect)만을 위해 코드를 반복 실행하는 용도라면 이 구문을 사용해서는 안 됩니다. 또한, 리스트 컴프리헨션이 두 줄을 넘어갈 정도로 길어진다면 가독성을 위해 일반 

### 메모리 효율의 극대화: 제너레이터 표현식

리스트 컴프리헨션은 리스트를 생성하는 데는 훌륭하지만, 수백만 개의 항목을 처리할 때는 메모리 문제가 발생할 수 있습니다. 리스트를 만들기 위해 모든 항목을 메모리에 저장하기 때문입니다.

이때 제너레이터 표현식(Generator Expression), 줄여서 제너레이터(genexp)를 사용하면 메모리 사용량을 획기적으로 줄일 수 있습니다. 제너레이터 표현식은 리스트를 통째로 만들지 않고, 필요할 때마다 한 번에 하나의 항목만 생성(yield)합니다.

튜플, 배열, 혹은 다른 타입의 시퀀스를 초기화할 때, 리스트 컴프리헨션을 사용한 후 해당 타입의 생성자를 호출하는 것은 메모리 낭비입니다. 예를 들어 tuple([...]) 대신 tuple(...) 형태의 제너레이터 표현식을 사용하세요. 특히 대용량 데이터를 다룰 때 이 차이는 매우 큽니다. 제너레이터 표현식은 최종 결과를 만들기 위한 중간 단계의 리스트를 생성하지 않으므로 훨씬 효율적입니다.

### 인덱스 대신 언패킹(Unpacking)을 사용하라

튜플을 레코드로 다룰 때 traveler[0], traveler[1]과 같이 인덱스를 사용하는 것은 코드의 가독성을 해치고 오류를 유발하기 쉽습니다. 대신, **튜플 언패킹(tuple unpacking)**을 적극적으로 활용하세요.

### 임시 변수 없이 값 교환하기

언패킹을 사용하면 임시 변수 없이도 두 변수의 값을 매우 우아하게 맞바꿀 수 있습니다.
```python
>>> a, b = b, a
```

또한, 여러 값을 반환하는 함수를 다룰 때도 언패킹이 유용합니다. 

os.path.split() 함수는 경로와 파일명을 튜플로 반환하는데, 이를 언패킹으로 쉽게 분리할 수 있습니다.

```python
>>> import os
>>> _, filename = os.path.split('/home/luciano/.ssh/id_rsa.pub')
>>> filename
'id_rsa.pub'
```

### *를 사용하여 가변 길이 이터러블을 안전하게 처리하라

* 구문은 처리하려는 시퀀스의 길이가 가변적일 때 특히 유용합니다. 특정 부분만 변수에 할당하고 나머지는 리스트로 받아 유연하게 처리할 수 있습니다.

### 매직 넘버(Magic Number) 대신 이름 있는 슬라이스를 사용하라

item[0:6], item[6:40]과 같이 의미를 알 수 없는 숫자를 코드에 하드코딩하는 대신, 의미 있는 이름을 가진 slice 객체를 사용하세요. 이는 코드를 훨씬 명확하게 만들고 유지보수를 용이하게 합니다.

### 원본 보존이 필요하면 sorted()를, 제자리 변경이 필요하면 list.sort()를 사용하라

list.sort()는 원본 리스트를 변경하고 None을 반환하기 때문에, 정렬된 결과를 새로운 변수에 할당하려는 흔한 실수를 방지해 줍니다 (예: sorted_list = my_list.sort()). 원본 시퀀스를 유지해야 할 때는 항상 sorted() 함수를 사용하세요. 메모리를 절약하고 원본을 변경해도 되는 명확한 경우에는 list.sort()를 사용합니다. 두 방법 모두 정렬 기준을 지정하는 key 인자와 정렬 순서를 바꾸는 reverse 인자를 지원하여 유연하게 사용할 수 있습니다.

### dict 생성자보다 컴프리헨션을 사용하라

이터러블로부터 딕셔너리를 생성할 때, dict() 생성자를 직접 사용하는 것보다 컴프리헨션을 사용하는 것이 더 유연하고 명확합니다. 컴프리헨션을 사용하면 위 예제처럼 항목을 변형하거나 필터링하는 로직을 간결하게 추가할 수 있습니다.

### 딕셔너리 병합 시 | 연산자를 사용하라

파이썬 3.9 이상을 사용한다면, 딕셔너리를 병합할 때 | 연산자를 사용하는 것이 가장 현대적이고 가독성 높은 방법입니다. 중복된 키의 값은 오른쪽 피연산자의 값으로 결정됩니다.

### JSON과 같은 반정형 데이터를 다룰 때 패턴 매칭을 활용하라

match/case를 사용하면 복잡한 if/elif 체인 없이도 데이터의 구조에 따라 코드를 명확하게 분기할 수 있습니다. 특히 API 버전이나 레코드 타입에 따라 구조가 다른 JSON 데이터를 처리할 때 가독성과 유지보수성을 크게 향상시킬 수 있습니다.

### setdefault를 이용한 효율적인 업데이트

리스트나 세트와 같은 가변 값을 값으로 가지는 딕셔너리를 업데이트할 때, setdefault를 사용하면 불필요한 키 조회를 피할 수 있어 코드가 더 간결하고 효율적이 됩니다.

딕셔너리에서 가변(mutable) 값을 가져와 업데이트해야 할 때, 다음과 같은 코드를 작성하기 쉽습니다.

```python
# 좋지 않은 예: 키 조회를 여러 번 수행
occurrences = index.get(word, [])  # 1. word 키로 값 조회
occurrences.append(location)       # 2. 값 수정
index[word] = occurrences          # 3. word 키로 다시 값 저장
```

```python
# 좋은 예: 단 한 번의 조회로 처리
index.setdefault(word, []).append(location)
```

### defaultdict: 자동으로 기본값 생성하기

collections.defaultdict는 없는 키에 접근할 때마다 지정된 default_factory를 호출하여 항목을 즉시 생성해 주는 dict의 서브클래스입니다. setdefault를 반복적으로 사용해야 하는 경우 defaultdict를 사용하면 코드를 더욱 단순화할 수 있습니다.

defaultdict의 마법과 같은 동작은 내부적으로 __missing__이라는 특별 메서드를 통해 구현됩니다. dict 클래스 자체에는 이 메서드가 없지만, dict를 상속하여 __missing__ 메서드를 구현하면 __getitem__(d[k] 구문)이 없는 키를 만났을 때 KeyError를 발생시키는 대신 우리가 구현한 __missing__ 메서드를 호출합니다.

이를 통해 훨씬 더 유연하고 맞춤화된 키 처리 로직을 구현할 수 있습니다.

### 사용자 정의 매핑은 dict 대신 UserDict를 상속하라

collections.UserDict는 dict를 직접 상속하는 것보다 훨씬 안전하고 편리한 기반 클래스입니다.

그 이유는 다음과 같습니다.

예측 가능한 동작: 내장 dict는 C로 구현된 최적화 때문에, 우리가 오버라이드한 특별 메서드(__setitem__ 등)가 다른 내장 메서드(__init__, update 등)에 의해 호출되지 않는 경우가 있습니다. 이는 예측하기 어려운 버그를 만듭니다.

쉬운 구현: UserDict는 내부적으로 실제 데이터를 self.data라는 dict 객체에 저장합니다. 따라서 우리는 복잡한 내부 로직을 신경 쓸 필요 없이, 필요한 메서드만 오버라이드하고 핵심 로직은 self.data에 위임하면 됩니다.

### 빈도를 세어야 할 때는 Counter를 사용하라

특정 항목의 출현 빈도를 계산해야 할 때, 직접 딕셔너리와 카운팅 로직을 구현하는 대신 Counter를 사용하세요. 

update, most_common과 같은 편리한 메서드를 기본으로 제공하여 코드를 크게 단순화할 수 있습니다. 

### 중첩된 스코프(Scope)를 표현할 때 ChainMap을 사용하라

ChainMap은 파이썬의 변수 조회 규칙처럼 중첩된 스코프를 구현하는 데 이상적입니다.  예를 들어, 지역 스코프, 전역 스코프, 내장 스코프를 순서대로 검색하는 로직을 

ChainMap으로 우아하게 구현할 수 있습니다.

### 내부 딕셔너리를 안전하게 노출할 때 MappingProxyType을 사용하라

클래스 내부에서 사용하는 딕셔너리를 외부로 노출해야 하지만, 외부에서 이를 수정하는 것을 막고 싶을 때 MappingProxyType으로 감싸서 반환하세요. 이는 내부 상태를 보호하는 훌륭한 방법입니다. 

### 순서를 유지하며 중복 제거하기

set()을 사용하면 항목의 순서가 유지되지 않습니다. 만약 중복은 제거하되 원래의 순서는 유지하고 싶다면, dict.fromkeys()를 사용하는 것이 현대적인 파이썬 기법입니다.

### 루프 대신 집합 연산자를 사용하라

집합 간의 관계를 다룰 때는 for나 if를 사용한 수동적인 로직보다 집합 연산자를 사용하는 것이 훨씬 더 파이썬답습니다. 코드가 더 선언적(declarative)이 되어 의도가 명확해지고, C로 구현된 내부 로직 덕분에 실행 속도도 더 빠릅니다

두 개의 세트 s1과 s2가 있을 때, 다음과 같은 중위(infix) 연산자를 사용할 수 있습니다.

s1 | s2: 합집합(Union). s1과 s2의 모든 원소를 포함하는 새로운 세트를 만듭니다.

s1 & s2: 교집합(Intersection). s1과 s2에 공통으로 존재하는 원소로 새로운 세트를 만듭니다.

s1 - s2: 차집합(Difference). s1에는 있지만 s2에는 없는 원소로 새로운 세트를 만듭니다.

s1 ^ s2: 대칭차집합(Symmetric Difference). s1 또는 s2 중 한 곳에만 존재하는 원소로 새로운 세트를 만듭니다.

### 딕셔너리 비교 시 뷰에 직접 세트 연산자를 사용하라

두 딕셔너리에서 공통된 키를 찾거나, 한쪽에만 존재하는 키-값 쌍을 찾는 등의 작업을 할 때, 뷰에 직접 세트 연산자를 사용하면 코드가 매우 간결하고 효율적이 됩니다.

### 유니코드 샌드위치 모델을 기억하라

텍스트를 처리하는 가장 좋은 방법은 "유니코드 샌드위치" 모델을 따르는 것입니다. 이는 입력 시점에서 가능한 한 빨리 바이트를 str로 디코딩하고, 프로그램 내부에서는 오직 str 객체만을 다루며, 출력 시점에서 가능한 한 늦게 str를 바이트로 인코딩하는 것을 의미합니다. 이 모델을 따르면 프로그램의 핵심 비즈니스 로직에서 인코딩/디코딩 문제를 완전히 분리하여 코드를 깔끔하고 견고하게 유지할 수 있습니다.

### errors 인수로 인코딩 오류를 명시적으로 처리하라

.encode() 메서드에 errors 인수를 전달하여 오류 처리 방식을 지정할 수 있습니다. 이는 데이터 손실을 방지하거나 문제 상황을 명확히 하는 데 도움이 됩니다.

### 텍스트 파일을 열 때는 항상 encoding 인수를 명시하라.

여러 컴퓨터나 다른 상황에서 실행되어야 하는 코드는 절대 기본 인코딩에 의존해서는 안 됩니다. 

open() 함수로 텍스트 파일을 열 때는 항상 encoding='utf-8'과 같이 명시적인 encoding 인수를 전달해야 합니다. 이는 플랫폼 간 호환성 문제를 예방하는 가장 확실한 방법입니다.

### UTF-8 파일을 읽을 때는 utf-8-sig를 사용하라.

utf-8-sig 코덱은 파일에 BOM이 있든 없든 정확하게 파일을 읽고, BOM 자체는 텍스트 내용에서 제외하므로 안전합니다. 파일을 쓸 때는 특별한 요구사항이 없는 한, 더 넓은 호환성을 위해 BOM이 없는 일반 'utf-8'을 사용하는 것이 좋습니다.

### 비교 전에는 항상 유니코드를 정규화하라.

바이트를 str로 올바르게 변환했다 해도, 유니코드 텍스트를 다루는 데에는 또 다른 복잡성이 존재합니다. 바로 문자열 비교 문제입니다. 유니코드에서는 눈으로 보기에는 똑같은 문자라도 내부적으로는 다른 코드 포인트 시퀀스로 표현될 수 있기 때문입니다.

"같은" 문자의 다른 표현
'café'라는 단어를 생각해 봅시다. 이 단어는 두 가지 방식으로 구성될 수 있습니다.

네 개의 코드 포인트 사용: 'c', 'a', 'f', 'é' (U+00E9)

다섯 개의 코드 포인트 사용: 'c', 'a', 'f', 'e', ´ (COMBINING ACUTE ACCENT, U+0301)

두 문자열은 화면에 정확히 똑같이 보이지만, 파이썬은 이 둘을 다른 것으로 간주합니다.

이 문제를 해결하기 위한 표준적인 방법은 unicodedata.normalize() 함수를 사용하여 문자열을 **정규화(normalize)**하는 것입니다. 정규화는 문자열을 표준적인 표현으로 변환하여, 의미상 같은 문자열이 동일한 바이트 표현을 갖도록 보장합니다.

### 모범 사례: 대부분의 경우 NFC를 사용하라.

unicodedata.normalize() 함수는 주로 네 가지 정규화 형식을 지원하지만, 가장 중요한 것은 NFC와 NFD입니다.

NFC (Normalization Form C): 가장 일반적으로 사용되는 형식입니다. 가능한 한 가장 짧은 문자열을 만들기 위해 코드 포인트를 **조합(Composition)**합니다. 예를 들어, 'e' + '´'(U+0301)를 단일 코드 포인트 'é'(U+00E9)로 변환합니다.

NFD (Normalization Form D): 코드 포인트를 기본 문자와 결합 문자로 **분해(Decomposition)**합니다. 예를 들어, 'é'(U+00E9)를 'e' + '´'(U+0301)로 변환합니다.

W3C는 웹에서 사용할 정규화 형식으로 NFC를 권장합니다. 사용자가 입력하는 텍스트는 대부분 이미 NFC 형식이므로, 데이터를 저장하거나 비교하기 전에 normalize('NFC', user_text)를 적용하여 일관성을 보장하는 것이 좋습니다.

### 대소문자를 무시한 비교에는 s1.casefold() == s2.casefold()를 사용하라

대소문자를 구분하지 않는 비교를 수행할 때는 str.lower()보다 str.casefold() 메서드를 사용하는 것이 더 정확하고 안전합니다. casefold()는 유니코드 표준에 따라 모든 문자를 소문자로 변환하는 더 공격적인 변환을 수행합니다.

예를 들어, 독일어의 에스체트('ß') 문자는 lower()로는 변하지 않지만, casefold()를 사용하면 'ss'로 올바르게 변환됩니다.

이는 국제적인 텍스트를 다룰 때 lower()보다 훨씬 신뢰할 수 있는 방법입니다.

### 국제화된 정렬에는 PyUCA를 사용하라.

기본 정렬의 문제점: 포르투갈어를 포함한 많은 라틴어 기반 언어에서는 발음 구별 기호(악센트 등)가 정렬 순서에 거의 영향을 주지 않습니다. 따라서 'cajá'는 'caja'처럼 취급되어 'caju'보다 앞에 와야 합니다. 하지만 파이썬의 기본 정렬은 코드 포인트 값에 따라 'cajá'를 뒤로 보냅니다.

파이썬 표준 라이브러리에서 비ASCII 텍스트를 정렬하는 표준적인 방법은 locale 모듈을 사용하는 것입니다. locale.strxfrm 함수를 sorted()의 key로 사용하면 로케일(locale, 지역 설정)에 맞는 정렬이 가능합니다.

`locale`을 사용한 정렬은 몇 가지 심각한 단점이 있어 실무에서 사용하기 까다롭습니다.

- **전역 설정 변경**: `locale.setlocale`은 프로세스 전역 설정을 변경하므로, 라이브러리에서 사용하는 것은 권장되지 않습니다.
- **OS 의존성**: 코드가 실행되는 운영체제에 해당 로케일이 설치되어 있어야 합니다.
- **이식성 부족**: 로케일 이름이 시스템마다 다를 수 있습니다.
- **신뢰성 문제**: 일부 운영체제(예: macOS)에서는 로케일이 올바르게 구현되지 않아 제대로 동작하지 않을 수 있습니다.

PyUCA 라이브러리는 UCA의 순수 파이썬 구현체로, OS나 로케일 설정에 의존하지 않고 일관된 정렬 결과를 제공합니다.

### **데이터 클래스를 코드 스멜(Code Smell)로 인식하기**

데이터 클래스는 매우 편리하지만, 남용될 경우 "코드 스멜"이 될 수 있습니다. 코드 스멜이란 코드 자체는 문제가 없지만 더 깊은 설계 문제를 암시하는 패턴을 의미합니다. 만약 어떤 클래스가 데이터 필드만 가지고 있고 자체적인 행위(메서드)가 거의 없다면, 그 클래스의 데이터를 조작하는 로직이 시스템의 다른 곳에 흩어져 있을 가능성이 높습니다. 이는 객체 지향의 기본 원칙(데이터와 행위를 함께 캡슐화)에 위배되며, 유지보수를 어렵게 만듭니다.  데이터 클래스는 시스템 경계를 넘나드는 데이터 전송용 객체(DTO)나 초기 프로토타이핑 단계에서는 유용하지만, 핵심 비즈니스 로직을 담는 객체는 점차 자신만의 행위를 갖도록 리팩토링해야 합니다.

### **JSON 직렬화를 위해 `._asdict()`를 활용하라**

`._asdict()` 메서드는 `namedtuple` 인스턴스의 데이터를 JSON과 같은 다른 형식으로 직렬화(serialize)할 때 매우 유용합니다

### **`frozen=True`와 `order=True`를 적극 활용하라**

`@dataclass` 데코레이터는 동작을 미세 조정할 수 있는 여러 키워드 인수를 받습니다.
`@dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)`

대부분의 경우 기본 설정으로 충분하지만, 다음 두 가지 옵션은 매우 유용합니다.

1.**`frozen=True`**: 인스턴스를 **"불변(immutable)"**으로 만듭니다. 생성된 후 필드에 값을 할당하려고 하면`FrozenInstanceError`가 발생합니다. 불변 객체는 예측 가능성을 높이고 버그를 줄여줍니다.`eq=True`와 함께 사용하면 자동으로 `__hash__` 메서드도 생성되어 인스턴스를 해시 가능(hashable)하게 만듭니다.

2.**`order=True`**: `__lt__`, `__le__`, `__gt__`, `__ge__`와 같은 비교 메서드를 자동으로 생성합니다. 이 옵션을 사용하면 데이터 클래스의 인스턴스들을 정렬할 수 있습니다.

### **가변 객체를 기본값으로 사용할 때는 `default_factory`를 사용하라**

`dataclasses.field` 함수를 사용하면 개별 필드에 대한 더 세밀한 제어가 가능합니다.

함수에서 매개변수 기본값으로 가변 객체를 사용하면 버그가 발생하기 쉬운 것처럼, 데이터 클래스 필드에서도 마찬가지입니다.

`@dataclass`는 이 문제를 방지하기 위해 `list`, `dict`, `set`을 직접 기본값으로 사용하는 것을 금지하고 `ValueError`를 발생시킵니다.

**올바른 해결책**은 `field` 함수의 `default_factory` 옵션에 `list`와 같은 0-인수 콜러블(callable)을 전달하는 것입니다. 이렇게 하면 인스턴스가 생성될 때마다 새로운 빈 리스트가 생성되어 모든 인스턴스가 같은 리스트를 공유하는 문제를 방지할 수 있습니다.

### `is`와 `==`를 올바르게 선택하라

프로그래밍을 할 때 우리는 객체의 정체성보다는 값의 동일성을 비교하는 경우가 훨씬 많습니다. 따라서 대부분의 경우 `==`를 사용해야 합니다.

is 연산자는 변수가 **싱글턴(singleton)** 객체를 가리키는지 확인할 때만 사용하는 것이 좋습니다. 가장 대표적인 예는 None`을 확인할 때입니다.

is는 오버로드할 수 없어서 ==보다 빠르지만, 그 차이는 미미합니다. 코드의 명확성과 정확성을 위해, None이나 다른 싱글턴 객체와의 비교가 아니라면 항상 ==`를 사용하세요.

### 튜플에는 가변 객체를 담지 마라

튜플에 리스트나 딕셔너리 같은 가변 객체를 담는 것은 혼란을 유발하고 버그의 원인이 될 수 있습니다. 특히 이런 튜플은 해시 가능(hashable)하지 않으므로 딕셔너리의 키나 세트의 원소로 사용할 수 없습니다.  객체의 상태가 완전히 고정되어야 하는 경우에는, 모든 항목이 불변인 튜플을 사용하세요.

### **복사의 종류를 명확히 이해하고 사용하라.**

객체를 복사할 때는 항상 얕은 복사와 깊은 복사 중 어떤 것이 필요한지 명확히 판단해야 합니다. 단순한 참조 공유로 충분하고 성능이 중요하다면 얕은 복사를, 객체의 완전한 독립성이 필요하다면 깊은 복사를 사용하세요. `copy` 모듈의 `copy()`와 `deepcopy()` 함수를 사용하면 의도를 명확하게 표현할 수 있습니다

### 함수 매개변수의 기본값으로 절대 가변 객체를 사용하지 마라.

이는 파이썬에서 가장 흔하면서도 치명적인 실수 중 하나입니다. 함수의 기본값은 함수가 **정의될 때 단 한 번만** 평가되어 함수 객체의 속성이 됩니다. 만약 이 기본값이 리스트나 딕셔너리 같은 가변 객체라면, 함수가 호출될 때마다 이 **동일한 객체**가 계속해서 사용되고 수정됩니다.

```python
class HauntedBus:
    """유령 승객이 출몰하는 버스 모델"""
    def __init__(self, passengers=[]):  # 😨 위험! 기본값이 가변 객체인 리스트다.
        self.passengers = passengers

```

**올바른 해결책**은 기본값으로 `None`을 사용하고, 함수 내부에서 `None`을 확인하여 새로운 객체를 생성하는 것입니다.

### 전달받은 가변 인수의 복사본을 만들어 사용하라.

메서드가 인수로 받은 객체를 수정할 의도가 명확하지 않다면, 인수를 그대로 인스턴스 변수에 할당(에일리어싱)하지 말고 항상 **복사본을 만들어** 사용해야 합니다.

```python
class Bus:
    def __init__(self, passengers=None):
        if passengers is None:
            self.passengers = []
        else:
            self.passengers = list(passengers) # 복사본을 만든다.
```

`list(passengers)`와 같이 생성자를 사용하면, 인수가 튜플이나 다른 이터러블이어도 항상 새로운 리스트가 생성되므로 코드가 더 유연하고 안전해집니다.

### `__del__` 특별 메서드를 사용하지 마라

__del__이라는 특별 메서드가 존재하지만, 이는 C++의 소멸자(destructor)가 아닙니다. 이 메서드는 객체가 파괴되기 직전에 인터프리터에 의해 호출되지만, 언제 호출될지 보장되지 않으며 사용하기가 매우 까다롭습니다.  일반적인 애플리케이션 코드에서는 `__del__`을 구현할 필요가 거의 없습니다.

**약한 참조 (Weak References):** 드물지만 객체의 참조 카운트를 증가시키지 않으면서 객체를 참조해야 할 때가 있습니다. 이때 **약한 참조(weak reference)**를 사용합니다. 약한 참조는 객체가 가비지 컬렉션되는 것을 막지 않으므로, 캐싱(caching)과 같은 특수한 용도에 사용됩니다.

### 함수를 변수에 할당하여 사용하라.

함수를 다른 변수에 할당하여 사용할 수 있습니다. 이는 코드의 가독성을 높이거나, 상황에 따라 다른 함수를 동적으로 선택하는 로직을 구현할 때 유용합니다.

### `key` 매개변수를 활용하여 복잡한 정렬 로직을 단순화하라.

복잡한 정렬 로직이 필요할 때, 직접 정렬 알고리즘을 구현하려 하지 말고, `sorted()`나 `list.sort()`의 `key` 매개변수에 간단한 함수를 전달하세요. 이는 코드의 의도를 명확하게 하고, 파이썬의 최적화된 정렬 성능을 활용하는 가장 좋은 방법입니다.

### `reduce` 대신 `sum()`, `all()`, `any()`와 같은 내장 함수를 사용하라.

`sum()`, `all()`, `any()`와 같은 내장 함수들은 `reduce`의 특정 사용 사례를 더 명확하고 효율적으로 처리합니다. `reduce`는 코드를 이해하기 어렵게 만들 수 있으므로, 꼭 필요한 경우가 아니라면 사용을 피하는 것이 좋습니다.

### `lambda`는 고계 함수의 인수로만 제한적으로 사용하라.

익명 함수의 가장 좋은 사용 사례는 고계 함수의 인수 목록 내에서 사용하는 것입니다. 예를 들어, 앞서 본

`reverse` 함수를 `lambda`로 대체하면 다음과 같습니다.

```python
>>> fruits = ['strawberry', 'fig', 'apple', 'cherry', 'raspberry', 'banana']
>>> sorted(fruits, key=lambda word: word[::-1])
['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']
```

람다 함수가 너무 복잡해서 주석이 필요하다면, 별도의 `def` 문을 사용해 이름을 가진 함수로 만드는 것이 좋습니다.

### `*`와 `**`를 활용하여 유연한 API를 설계하라

`*args`와 `**kwargs` 패턴을 사용하면 함수가 임의의 개수의 위치 인수와 키워드 인수를 받을 수 있어 매우 유연한 API를 만들 수 있습니다. 키워드 전용 인수는 API의 명확성을 높여 버그를 줄이는 데 도움이 됩니다.

**예:** `tag` 함수는 HTML 태그를 생성하며, 파이썬의 유연한 인수 처리 방식을 잘 보여줍니다.

```python
def tag(name, *content, class_=None, **attrs):
    """Generate one or more HTML tags"""
    # ... 함수 본문 ...
```

- `name`: 첫 번째 위치 인수입니다.
- `content`: `name` 뒤에 오는 임의 개수의 위치 인수를 `content`라는 튜플에 담습니다.
- `class_`: 키워드 전용 인수로, 반드시 `class_='sidebar'`와 같이 키워드로만 전달해야 합니다. `content` 뒤에 오는 모든 매개변수는 키워드 전용이 됩니다.
- `*attrs`: 명시적으로 지정되지 않은 모든 키워드 인수를 `attrs`라는 딕셔너리에 담습니다.

### `lambda` 대신 `itemgetter`와 `attrgetter`를 사용하라.

`operator` 모듈은 파이썬의 내장 연산자에 해당하는 함수들을 제공합니다.

`lambda a, b: a*b`와 같은 간단한 `lambda` 함수를 작성하는 대신 `operator.mul`을 사용하면 코드가 더 깔끔하고 명확해집니다.

또한, `itemgetter`와 `attrgetter`는 시퀀스의 항목이나 객체의 속성을 가져오는 함수를 생성하는 팩토리 함수입니다.

`sorted(metro_data, key=lambda fields: fields[1])`과 같은 코드는 `sorted(metro_data, key=itemgetter(1))`로 더 간결하게 표현할 수 있습니다. 이는 더 읽기 쉽고 효율적입니다.

### **함수의 특정 버전을 만들어야 할 때 `partial`을 사용하라.**

`functools.partial`은 기존 함수의 일부 인수를 특정 값으로 "고정"하여 새로운 함수를 만드는 고계 함수입니다. 이는 인수의 개수가 다른 API에 함수를 콜백으로 전달해야 할 때 매우 유용합니다.

복잡한 함수의 일부 인수를 고정하여 더 간단한 버전의 함수를 만들고 싶을 때 `partial`을 사용하면 편리합니다. 예를 들어, 유니코드 정규화를 위해 `normalize('NFC', s)`를 자주 사용한다면, `partial`을 사용하여 `nfc` 함수를 만들 수 있습니다.

```python
import unicodedata
from functools import partial

# normalize 함수의 첫 번째 인수를 'NFC'로 고정
nfc = partial(unicodedata.normalize, 'NFC')

>>> s1 = 'café'
>>> s2 = 'cafe\u0301'
>>> s1 == s2
False
>>> nfc(s1) == nfc(s2)
True
```

### **Python 3.10+): `|` 연산자로 더 간결하게 표현하라**

Python 3.10부터는 `Union`을 `|` 연산자로 더 간결하게 표현할 수 있습니다. 예를 들어, `str | None`은 `Union[str, None]`과 동일하며 `typing` 모듈에서 `Union`을 임포트할 필요가 없어 더 편리합니다

### **(Python 3.9+): 내장 컬렉션에 제네릭 문법을 사용하라**

Python 3.9부터는 `list`, `set`, `dict`와 같은 내장 컬렉션 타입에 대괄호를 사용하여 항목의 타입을 직접 명시할 수 있습니다.

- `list[str]`: 모든 항목이 문자열인 리스트
- `set[int]`: 모든 항목이 정수인 세트
- `dict[str, float]`: 키는 문자열이고 값은 부동소수점인 딕셔셔너리

Python 3.8 이전 버전에서는 `typing.List`, `typing.Set`, `typing.Dict`와 같이 `typing` 모듈에 있는 대문자로 시작하는 타입을 임포트해서 사용해야 했습니다.

### 레코드 역할의 튜플은 `typing.NamedTuple`로 명확성을 높여라

튜플은 두 가지 주요 용도로 사용되므로, 어노테이션 방식도 용도에 따라 다릅니다.

1. **레코드로 사용할 때**: 각 항목의 타입이 다른 고정 길이 튜플은 `tuple[str, float]`와 같이 각 위치의 타입을 명시합니다.
2. **불변 시퀀스로 사용할 때**: 모든 항목의 타입이 같은 가변 길이 튜플은 `tuple[int, ...]`와 같이 타입과 함께 줄임표(`...`)를 사용합니다.

### 함수 매개변수에는 구체 타입 대신 추상 베이스 클래스(ABC)를 사용하라.

함수가 `list`를 인수로 받는다고 가정해 봅시다. 만약 함수의 로직이 단지 `for` 루프를 통해 항목을 순회하는 것이 전부라면, 굳이 `list` 타입만 받도록 제한할 필요가 없습니다. 튜플, `deque`, 심지어 사용자가 직접 만든 시퀀스 타입도 인수로 받을 수 있어야 합니다.

- **제한적인 힌트:** `def func(items: list[str]) -> None:`
- **유연한 힌트:** `def func(items: abc.Sequence[str]) -> None:`

`abc.Sequence`와 같은 추상 베이스 클래스를 사용하면, 함수가 요구하는 최소한의 인터페이스(예: 시퀀스 프로토콜)만 만족하면 어떤 타입의 객체든 인수로 전달할 수 있습니다. 이는 호출자에게 더 큰 유연성을 제공합니다.

### **숫자 타입 힌트에는 구체 타입, `Union`, 또는 프로토콜을 사용하라.**

`numbers` 모듈의 ABC(예: `numbers.Integral`, `numbers.Real`)는 런타임에 타입을 검사하는 데는 유용하지만, **정적 타입 체커는 이를 지원하지 않습니다**. 따라서 타입 힌트에는 `numbers` ABC를 사용하는 것을 피해야 합니다.

숫자 인수를 어노테이트할 때는 `int`, `float` 같은 구체 타입을 사용하거나, `Union[float, Decimal, Fraction]`처럼 여러 타입을 나열하거나, 숫자 프로토콜(나중에 다룸)을 사용하는 것이 좋습니다.

### `bound`를 사용하여 타입 변수에 제약 조건을 걸어라.

때로는 타입 변수가 아무 타입이나 되는 것을 원치 않을 수 있습니다. 예를 들어, 주어진 데이터에서 최빈값을 구하는 `mode` 함수는 인수로 받은 컬렉션의 항목들이 반드시 **해시 가능(hashable)**해야 합니다.

이때 `TypeVar`의 `bound` 키워드 인수를 사용하여 타입 변수가 가질 수 있는 타입을 제한할 수 있습니다.

```python
from collections.abc import Iterable, Hashable
from typing import TypeVar

HashableT = TypeVar('HashableT', bound=Hashable)

def mode(data: Iterable[HashableT]) -> HashableT:
    # ...

```

`bound=Hashable`은 `HashableT`가 `Hashable` 또는 그 서브타입만 될 수 있음을 의미합니다. 이렇게 하면 타입 체커는 `mode` 함수에 해시 불가능한 객체(예: 리스트)의 이터러블을 전달하는 코드를 오류로 지적할 수 있습니다.

### 데코레이터를 만들 때는 항상 `@functools.wraps`를 사용하라.

이 문제를 해결하기 위한 표준적인 방법은 `functools.wraps` 데코레이터를 래퍼 함수에 적용하는 것입니다.

`@functools.wraps(func)`는 원본 함수(`func`)의 `__name__`, `__doc__`, `__annotations__` 등 중요한 속성들을 래퍼 함수(`clocked`)로 복사해 줍니다.

### (Python 3.9+): 간단한 캐싱에는 `@functools.cache`를 사용하라.

`@functools.cache`는 LRU(Least Recently Used) 로직 없이 결과를 단순하게 캐싱하는 가장 간단한 방법입니다. 재귀적으로 피보나치 수를 구하는 함수처럼 동일한 계산이 반복되는 경우에 극적인 성능 향상을 가져올 수 있습니다. 

### **인수의 타입에 따라 다른 로직을 수행해야 할 때는 `@singledispatch`를 사용하라.**

@singledispatch는 if/elif 체인 없이도 타입에 따라 다른 함수를 실행할 수 있게 해주는 우아한 방법입니다.

```python
from functools import singledispatch
import html

@singledispatch
def htmlize(obj: object) -> str:
    content = html.escape(repr(obj))
    return f'<pre>{content}</pre>'

@htmlize.register
def _(text: str) -> str:
    content = html.escape(text).replace('\n', '<br/>\n')
    return f'<p>{content}</p>'

@htmlize.register
def _(n: int) -> str:
    return f'<pre>{n} (0x{n:x})</pre>'
```

1. `@singledispatch`로 기본 함수(`object` 타입을 처리)를 장식합니다.
2. `@htmlize.register`를 사용하여 특정 타입(`str`, `int` 등)을 처리할 함수를 추가로 등록합니다.

이 기법은 서로 다른 모듈에서 제네릭 함수에 기능을 추가할 수 있게 해주어 코드의 모듈성을 높여줍니다.

### **대체 생성자는 `@classmethod`로 구현하라.**

주 생성자인 __init__ 외에 다른 방식으로 객체를 생성해야 할 때는 클래스 메서드를 사용하는 것이 표준적인 파이썬 관례입니다. 이는 코드의 의도를 명확하게 하고, 다양한 생성 로직을 깔끔하게 분리해 줍니다

`@classmethod` 데코레이터는 메서드가 호출되는 방식을 변경하여, 첫 번째 인수로 인스턴스(`self`) 대신 클래스 자체(`cls`)를 받도록 합니다.

**코드 예제: `@classmethod`로 구현된 `frombytes`**

```python
# Vector2d 클래스 내부
@classmethod
def frombytes(cls, octets):
    typecode = chr(octets[0]) # 1
    memv = memoryview(octets[1:]).cast(typecode) # 2
    return cls(*memv) # 3
```

### **불변성을 강제하려면 인스턴스 속성을 비공개(private)로 만들고, `@property`를 통해 읽기 전용으로 노출하라.**

사용자가 `v1.x = 7`과 같이 실수로 벡터의 요소를 변경하는 것을 막기 위해, `x`와 `y` 속성을 읽기 전용 프로퍼티(property)로 만들 수 있습니다.

**코드 예제: 읽기 전용 프로퍼티 구현**

```python
# Vector2d 클래스 내부
def __init__(self, x, y):
    self.__x = float(x) # 1
    self.__y = float(y)

@property
def x(self): # 2
    return self.__x

@property
def y(self):
    return self.__y
```

1. **비공개 속성**: `__init__`에서 `x`와 `y` 값을 비공개 속성인 `__x`와 `__y`에 저장합니다. 이름 앞에 더블 언더스코어(
    
    `__`)를 붙이면, 파이썬은 이 속성 이름에 **이름 장식(name mangling)**을 적용하여 외부에서의 우발적인 접근을 어렵게 만듭니다.
    
2. **프로퍼티 게터(getter)**: `@property` 데코레이터를 사용하여 `x`와 `y`에 대한 게터 메서드를 정의합니다. 이제 사용자가 `v1.x`를 읽으려고 하면 이 메서드가 호출됩니다. 세터(setter) 메서드가 없으므로, `v1.x = 7`과 같은 할당 시도는 `AttributeError`를 발생시킵니다.

### `__hash__`는 `__eq__`에서 비교하는 속성들을 기반으로 계산하라.

a == b가 참이면 hash(a) == hash(b)도 반드시 참이어야 합니다.  이를 보장하는 가장 간단하고 올바른 방법은

`__eq__`에서 비교하는 속성들을 튜플로 묶어 그 튜플의 해시값을 반환하는 것입니다.

### (Python 3.10+): 위치 패턴을 지원하려면 `__match_args__`를 정의하라.

Python 3.10에 도입된 `match/case` 문에서 사용자 정의 클래스는 기본적으로 **키워드 패턴**만 지원합니다 (예: `case Vector2d(x=0, y=0):`).

더 간결한 **위치 패턴**(예: `case Vector2d(0, 0):`)을 지원하게 하려면, 클래스 속성으로 `__match_args__`를 추가해야 합니다. 이 속성은 위치 패턴 매칭에 사용할 인스턴스 속성의 이름들을 순서대로 담은 문자열 튜플입니다.

### **클래스 데이터를 명시적으로 변경하려면 서브클래싱을 사용하라.**

특정 인스턴스가 아닌, 모든 인스턴스의 기본 동작을 바꾸고 싶다면 클래스 속성을 직접 변경하는 것보다, 해당 속성만 오버라이딩하는 서브클래스를 만드는 것이 더 명시적이고 파이썬다운 방법입니다.